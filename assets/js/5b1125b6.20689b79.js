"use strict";(globalThis.webpackChunkmux_website=globalThis.webpackChunkmux_website||[]).push([[347],{4903(e,n,s){s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>x,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"reference/expressions","title":"Expressions","description":"This document describes expression evaluation rules in Mux.","source":"@site/docs/reference/expressions.md","sourceDirName":"reference","slug":"/reference/expressions","permalink":"/docs/reference/expressions","draft":false,"unlisted":false,"editUrl":"https://github.com/derekcorniello/mux-lang/tree/main/mux-website/docs/reference/expressions.md","tags":[],"version":"current","frontMatter":{}}');var r=s(4848),l=s(8453);const a={},t="Expressions",d={},c=[{value:"Expression Classification",id:"expression-classification",level:2},{value:"Primary Expressions",id:"primary-expressions",level:2},{value:"Literals",id:"literals",level:3},{value:"Identifiers",id:"identifiers",level:3},{value:"Parenthesized Expressions",id:"parenthesized-expressions",level:3},{value:"List Literals",id:"list-literals",level:2},{value:"Type Inference for Lists",id:"type-inference-for-lists",level:3},{value:"Map Literals",id:"map-literals",level:2},{value:"Type Inference",id:"type-inference",level:3},{value:"Set Literals",id:"set-literals",level:2},{value:"Type Inference",id:"type-inference-1",level:3},{value:"Lambda Expressions",id:"lambda-expressions",level:2},{value:"Lambda Capture",id:"lambda-capture",level:3},{value:"Enum Instantiation",id:"enum-instantiation",level:2},{value:"Class Instantiation",id:"class-instantiation",level:2},{value:"Generic Classes",id:"generic-classes",level:3},{value:"Member Access",id:"member-access",level:2},{value:"Field Access",id:"field-access",level:3},{value:"Method Call",id:"method-call",level:3},{value:"Array/List Access",id:"arraylist-access",level:2},{value:"Safe Access with <code>.get()</code>",id:"safe-access-with-get",level:3},{value:"Arithmetic Expressions",id:"arithmetic-expressions",level:2},{value:"Evaluation Order",id:"evaluation-order",level:3},{value:"Logical Expressions",id:"logical-expressions",level:2},{value:"Short-Circuit Evaluation",id:"short-circuit-evaluation",level:3},{value:"Truthiness",id:"truthiness",level:3},{value:"Comparison Expressions",id:"comparison-expressions",level:2},{value:"String Comparison",id:"string-comparison",level:3},{value:"Range Expressions",id:"range-expressions",level:2},{value:"Conditional Expressions",id:"conditional-expressions",level:2},{value:"Expression Statements",id:"expression-statements",level:2},{value:"Type of Expressions",id:"type-of-expressions",level:2},{value:"Constant Folding",id:"constant-folding",level:2},{value:"Value Category",id:"value-category",level:2},{value:"L-values (Place Expressions)",id:"l-values-place-expressions",level:3},{value:"R-values (Value Expressions)",id:"r-values-value-expressions",level:3},{value:"Evaluation Order Guarantees",id:"evaluation-order-guarantees",level:2},{value:"Side Effects",id:"side-effects",level:2},{value:"See Also",id:"see-also",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"expressions",children:"Expressions"})}),"\n",(0,r.jsx)(n.p,{children:"This document describes expression evaluation rules in Mux."}),"\n",(0,r.jsx)(n.h2,{id:"expression-classification",children:"Expression Classification"}),"\n",(0,r.jsx)(n.p,{children:"Expressions are categorized by their evaluation behavior:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Category"}),(0,r.jsx)(n.th,{children:"Description"}),(0,r.jsx)(n.th,{children:"Examples"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Value expressions"})}),(0,r.jsx)(n.td,{children:"Produce a value"}),(0,r.jsx)(n.td,{children:"Literals, variables, operators"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Place expressions"})}),(0,r.jsx)(n.td,{children:"Denote storage locations"}),(0,r.jsx)(n.td,{children:"Variables, array elements, fields"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Void expressions"})}),(0,r.jsx)(n.td,{children:"Produce no value"}),(0,r.jsx)(n.td,{children:"Some function calls"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"primary-expressions",children:"Primary Expressions"}),"\n",(0,r.jsx)(n.h3,{id:"literals",children:"Literals"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"42              // Integer literal (type: int, value: 42)\n3.14159         // Float literal (type: float, value: 3.14159)\n\"hello\"         // String literal (type: string, value: \"hello\")\n'a'             // Char literal (type: char, value: 'a')\ntrue            // Boolean literal (type: bool, value: true)\nfalse           // Boolean literal (type: bool, value: false)\nNone            // None literal (type: Optional<T>.None)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"identifiers",children:"Identifiers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto x = 42     // x is an identifier expression\nprint(x)        // x evaluates to its current value\nx = 100         // x is a place expression (assignment target)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"parenthesized-expressions",children:"Parenthesized Expressions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto x = (1 + 2) * 3    // x = 9\nauto y = (result)       // y has same type as result\n"})}),"\n",(0,r.jsx)(n.h2,{id:"list-literals",children:"List Literals"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto nums = [1, 2, 3]           // list<int>\nauto empty = []                 // ERROR: needs explicit type\nauto typed = list<int>()        // Empty list with type\nauto mixed = [1, "two", 3.0]   // Mixed types allowed\n'})}),"\n",(0,r.jsx)(n.h3,{id:"type-inference-for-lists",children:"Type Inference for Lists"}),"\n",(0,r.jsx)(n.p,{children:"The element type is inferred from the contents:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto nums = [1, 2, 3]           // list<int>\nauto strs = ["a", "b"]          // list<string>\nauto floats = [1.0, 2.0]        // list<float>\nauto objects = [Circle.new(1)]   // list<Circle>\n'})}),"\n",(0,r.jsx)(n.p,{children:"Empty lists require explicit type annotation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"list<int> empty = []            // Valid: explicit type\nauto empty = list<int>()        // Valid: explicit constructor\nauto bad = []                   // ERROR: cannot infer type\n"})}),"\n",(0,r.jsx)(n.h2,{id:"map-literals",children:"Map Literals"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto scores = {"Alice": 90, "Bob": 85}\nauto nested = {"name": "Mux", "version": 1}\nauto complex = {"key": [1, 2, 3]}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"type-inference",children:"Type Inference"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto scores = {"Alice": 90}     // map<string, int>\nauto mixed = {"a": 1, "b": "x"}  // map<string, Value>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"set-literals",children:"Set Literals"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto tags = {"urgent", "important", "review"}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"type-inference-1",children:"Type Inference"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto nums = {1, 2, 3}           // set<int>\nauto strs = {"a", "b", "c"}     // set<string>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"lambda-expressions",children:"Lambda Expressions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto square = func(int n) returns int {\n    return n * n\n}\n\nauto add = func(int a, int b) {\n    return a + b\n}\n\n// Type: func(int, int) -> int\n"})}),"\n",(0,r.jsx)(n.h3,{id:"lambda-capture",children:"Lambda Capture"}),"\n",(0,r.jsx)(n.p,{children:"Lambdas capture variables from enclosing scope:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto multiplier = 10\nauto times10 = func(int x) returns int {\n    return x * multiplier  // Captures multiplier\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"enum-instantiation",children:"Enum Instantiation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"enum Option<T> {\n    Some(T)\n    None\n}\n\nauto opt = Option<int>.Some(42)\nauto none = Option<int>.None\nauto inferred = Some(42)  // Type inferred from context\n"})}),"\n",(0,r.jsx)(n.h2,{id:"class-instantiation",children:"Class Instantiation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"class Circle {\n    float radius\n\n    func new(float r) returns void {\n        self.radius = r\n    }\n}\n\nauto c = Circle.new(5.0)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"generic-classes",children:"Generic Classes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"class Stack<T> {\n    list<T> items\n}\n\nauto int_stack = Stack<int>.new()\nauto str_stack = Stack<string>.new()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"member-access",children:"Member Access"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto r = circle.radius           // Field access\nauto len = str.length()          // Method call\nauto elem = list[0]              // Array access\n"})}),"\n",(0,r.jsx)(n.h3,{id:"field-access",children:"Field Access"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"class Point {\n    int x\n    int y\n}\n\nauto p = Point.new()\nauto x_coord = p.x  // Read field\np.x = 10            // Write to field\n"})}),"\n",(0,r.jsx)(n.h3,{id:"method-call",children:"Method Call"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto result = numbers.size()     // Method call\nauto upper = "hello".to_upper()  // Method on literal\n'})}),"\n",(0,r.jsx)(n.h2,{id:"arraylist-access",children:"Array/List Access"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto first = myList[0]           // Read element\nmyList[0] = 42                   // Write element\n\n// Out of bounds is runtime error\n// auto bad = myList[1000]        // Runtime error\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"safe-access-with-get",children:["Safe Access with ",(0,r.jsx)(n.code,{children:".get()"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto first = myList.get(0)       // Optional<int>\nmatch myList.get(0) {\n    Some(value) { print(value) }\n    None { print("out of bounds") }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"arithmetic-expressions",children:"Arithmetic Expressions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto sum = a + b\nauto diff = a - b\nauto product = a * b\nauto quotient = a / b\nauto remainder = a % b\nauto power = a ** b\n"})}),"\n",(0,r.jsx)(n.h3,{id:"evaluation-order",children:"Evaluation Order"}),"\n",(0,r.jsx)(n.p,{children:"Left operand is always evaluated before right operand:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto i = 0\nauto x = i++ + i++   // x = 0, i = 2\n"})}),"\n",(0,r.jsx)(n.h2,{id:"logical-expressions",children:"Logical Expressions"}),"\n",(0,r.jsx)(n.h3,{id:"short-circuit-evaluation",children:"Short-Circuit Evaluation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"// AND: b only evaluated if a is true\nauto result = a && b\n\n// OR: b only evaluated if a is false\nauto result = a || b\n"})}),"\n",(0,r.jsx)(n.h3,{id:"truthiness",children:"Truthiness"}),"\n",(0,r.jsxs)(n.p,{children:["Only ",(0,r.jsx)(n.code,{children:"bool"})," values are allowed in logical expressions:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto x = 1\n// auto y = x && x  // ERROR: int cannot be used with &&\n"})}),"\n",(0,r.jsx)(n.h2,{id:"comparison-expressions",children:"Comparison Expressions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto equal = a == b\nauto not_equal = a != b\nauto less = a < b\nauto less_equal = a <= b\nauto greater = a > b\nauto greater_equal = a >= b\n"})}),"\n",(0,r.jsx)(n.h3,{id:"string-comparison",children:"String Comparison"}),"\n",(0,r.jsx)(n.p,{children:"String comparison is lexicographic (Unicode codepoint order):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto a = "abc"\nauto b = "abd"\nauto result = a < b  // true\n'})}),"\n",(0,r.jsx)(n.h2,{id:"range-expressions",children:"Range Expressions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto nums = range(0, 10)  // list<int>: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"conditional-expressions",children:"Conditional Expressions"}),"\n",(0,r.jsxs)(n.p,{children:["Mux does not have a ternary ",(0,r.jsx)(n.code,{children:"? :"})," operator. Use ",(0,r.jsx)(n.code,{children:"if"}),"/",(0,r.jsx)(n.code,{children:"else"})," as a statement:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"// Not valid Mux:\n// auto x = condition ? 1 : 2\n\n// Instead:\nif condition {\n    auto x = 1\n} else {\n    auto x = 2\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"expression-statements",children:"Expression Statements"}),"\n",(0,r.jsx)(n.p,{children:"Expressions can be used as statements when side effects are desired:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'some_function()          // Function call\nx++                       // Increment\nx += 5                    // Compound assignment\nprint("message")          // Print for side effect\n'})}),"\n",(0,r.jsx)(n.h2,{id:"type-of-expressions",children:"Type of Expressions"}),"\n",(0,r.jsx)(n.p,{children:"The compiler determines the type of each expression:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Expression"}),(0,r.jsx)(n.th,{children:"Type"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Integer literal"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Float literal"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"String literal"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Boolean literal"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"List literal"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"list<T>"})," (inferred)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Identifier"}),(0,r.jsx)(n.td,{children:"Declared or inferred type"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"a + b"})}),(0,r.jsxs)(n.td,{children:["Type of ",(0,r.jsx)(n.code,{children:"a"})," and ",(0,r.jsx)(n.code,{children:"b"})," (must match)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"a == b"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"a && b"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"!a"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"range(a, b)"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"list<int>"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Lambda"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"func(...) -> ..."})})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"constant-folding",children:"Constant Folding"}),"\n",(0,r.jsx)(n.p,{children:"The compiler performs constant folding on simple expressions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto x = 1 + 2 + 3    // Optimized to 6 at compile time\nauto y = 2 ** 10      // Optimized to 1024\nauto z = "hello" + "world"  // Optimized to "helloworld"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"value-category",children:"Value Category"}),"\n",(0,r.jsx)(n.h3,{id:"l-values-place-expressions",children:"L-values (Place Expressions)"}),"\n",(0,r.jsx)(n.p,{children:"Can appear on the left side of assignment:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"x = 42           // x is an l-value\na[i] = 10        // array element is an l-value\nobj.field = 5    // field is an l-value\n*r = 10          // dereferenced pointer is an l-value\n"})}),"\n",(0,r.jsx)(n.h3,{id:"r-values-value-expressions",children:"R-values (Value Expressions)"}),"\n",(0,r.jsx)(n.p,{children:"Produce values but cannot be assigned to:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"42              // Literal r-value\na + b           // Arithmetic r-value\nf()             // Function call r-value (unless returns reference)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"evaluation-order-guarantees",children:"Evaluation Order Guarantees"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Left-to-right evaluation"})," for most binary operators"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Short-circuit evaluation"})," for ",(0,r.jsx)(n.code,{children:"&&"})," and ",(0,r.jsx)(n.code,{children:"||"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function arguments"})," evaluated before the function body executes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No unspecified evaluation order"})," within expressions"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"side-effects",children:"Side Effects"}),"\n",(0,r.jsx)(n.p,{children:"An expression has a side effect if it modifies state:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Assignment expressions"}),"\n",(0,r.jsx)(n.li,{children:"Increment/decrement expressions"}),"\n",(0,r.jsx)(n.li,{children:"Function calls that modify state"}),"\n",(0,r.jsx)(n.li,{children:"Method calls that modify state"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/reference/grammar",children:"Grammar"})," - Expression syntax"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/reference/operators",children:"Operators"})," - Operator precedence"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/reference/type-system",children:"Type System"})," - Type rules"]}),"\n"]})]})}function x(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453(e,n,s){s.d(n,{R:()=>a,x:()=>t});var i=s(6540);const r={},l=i.createContext(r);function a(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);