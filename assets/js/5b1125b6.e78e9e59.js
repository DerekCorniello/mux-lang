"use strict";(globalThis.webpackChunkmux_website=globalThis.webpackChunkmux_website||[]).push([[347],{4903(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>x,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"reference/expressions","title":"Expressions","description":"This document describes expression evaluation rules in Mux.","source":"@site/docs/reference/expressions.md","sourceDirName":"reference","slug":"/reference/expressions","permalink":"/docs/reference/expressions","draft":false,"unlisted":false,"editUrl":"https://github.com/derekcorniello/mux-lang/tree/main/mux-website/docs/reference/expressions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Lexical Structure","permalink":"/docs/reference/lexical-structure"},"next":{"title":"Statements","permalink":"/docs/reference/statements"}}');var r=s(4848),l=s(8453);const t={},a="Expressions",c={},d=[{value:"Expression Classification",id:"expression-classification",level:2},{value:"Primary Expressions",id:"primary-expressions",level:2},{value:"Literals",id:"literals",level:3},{value:"Identifiers",id:"identifiers",level:3},{value:"Parenthesized Expressions",id:"parenthesized-expressions",level:3},{value:"Tuple Literals",id:"tuple-literals",level:2},{value:"List Literals",id:"list-literals",level:2},{value:"Type Inference for Lists",id:"type-inference-for-lists",level:3},{value:"Map Literals",id:"map-literals",level:2},{value:"Type Inference",id:"type-inference",level:3},{value:"Set Literals",id:"set-literals",level:2},{value:"Type Inference",id:"type-inference-1",level:3},{value:"Lambda Expressions",id:"lambda-expressions",level:2},{value:"Lambda Capture",id:"lambda-capture",level:3},{value:"Enum Instantiation",id:"enum-instantiation",level:2},{value:"Class Instantiation",id:"class-instantiation",level:2},{value:"Generic Classes",id:"generic-classes",level:3},{value:"Member Access",id:"member-access",level:2},{value:"Field Access",id:"field-access",level:3},{value:"Method Call",id:"method-call",level:3},{value:"Array/List Access",id:"arraylist-access",level:2},{value:"Safe Access with <code>.get()</code>",id:"safe-access-with-get",level:3},{value:"Range Expressions",id:"range-expressions",level:2},{value:"Conditional Expressions",id:"conditional-expressions",level:2},{value:"Expression Statements",id:"expression-statements",level:2},{value:"Type of Expressions",id:"type-of-expressions",level:2},{value:"See Also",id:"see-also",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"expressions",children:"Expressions"})}),"\n",(0,r.jsx)(n.p,{children:"This document describes expression evaluation rules in Mux."}),"\n",(0,r.jsx)(n.h2,{id:"expression-classification",children:"Expression Classification"}),"\n",(0,r.jsx)(n.p,{children:"Expressions are categorized by their evaluation behavior:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Category"}),(0,r.jsx)(n.th,{children:"Description"}),(0,r.jsx)(n.th,{children:"Examples"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Value expressions"})}),(0,r.jsx)(n.td,{children:"Produce a value"}),(0,r.jsx)(n.td,{children:"Literals, variables, operators"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Place expressions"})}),(0,r.jsx)(n.td,{children:"Denote storage locations"}),(0,r.jsx)(n.td,{children:"Variables, array elements, fields"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Void expressions"})}),(0,r.jsx)(n.td,{children:"Produce no value"}),(0,r.jsx)(n.td,{children:"Some function calls"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"primary-expressions",children:"Primary Expressions"}),"\n",(0,r.jsx)(n.h3,{id:"literals",children:"Literals"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"42              // Integer literal (type: int, value: 42)\n3.14159         // Float literal (type: float, value: 3.14159)\n\"hello\"         // String literal (type: string, value: \"hello\")\n'a'             // Char literal (type: char, value: 'a')\ntrue            // Boolean literal (type: bool, value: true)\nfalse           // Boolean literal (type: bool, value: false)\nNone            // None literal (type: Optional<T>.None)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"identifiers",children:"Identifiers"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto x = 42     // x is an identifier expression\nprint(x)        // x evaluates to its current value\nx = 100         // x is a place expression (assignment target)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"parenthesized-expressions",children:"Parenthesized Expressions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto x = (1 + 2) * 3    // x = 9\nauto y = (result)       // y has same type as result\n"})}),"\n",(0,r.jsx)(n.h2,{id:"tuple-literals",children:"Tuple Literals"}),"\n",(0,r.jsx)(n.p,{children:"Tuples are fixed size pairs with exactly two elements:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto pair = (1, "one")\nauto nested = ((1, 2), ("a", "b"))\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Access tuple fields with ",(0,r.jsx)(n.code,{children:".left"})," and ",(0,r.jsx)(n.code,{children:".right"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"print(pair.left.to_string())\nprint(pair.right.to_string())\n"})}),"\n",(0,r.jsx)(n.h2,{id:"list-literals",children:"List Literals"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto nums = [1, 2, 3]           // list<int>\nauto empty = []                 // ERROR: needs explicit type\nauto typed = list<int>.new()    // Empty list with type\nauto mixed = [1, "two", 3.0]    // Mixed types allowed\n'})}),"\n",(0,r.jsx)(n.h3,{id:"type-inference-for-lists",children:"Type Inference for Lists"}),"\n",(0,r.jsx)(n.p,{children:"The element type is inferred from the contents:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto nums = [1, 2, 3]           // list<int>\nauto strs = ["a", "b"]          // list<string>\nauto floats = [1.0, 2.0]        // list<float>\nauto objects = [Circle.new(1)]  // list<Circle>\n'})}),"\n",(0,r.jsx)(n.p,{children:"Empty lists require explicit type annotation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"list<int> empty = []            // Valid: explicit type\nauto empty = list<int>.new()    // Valid: explicit constructor\nauto bad = []                   // ERROR: cannot infer type\n"})}),"\n",(0,r.jsx)(n.h2,{id:"map-literals",children:"Map Literals"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto scores = {"Alice": 90, "Bob": 85}\nauto nested = {"name": "Mux", "version": 1}\nauto complex = {"key": [1, 2, 3]}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"type-inference",children:"Type Inference"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto scores = {"Alice": 90}      // map<string, int>\nauto mixed = {"a": 1, "b": "x"}  // map<string, Value>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"set-literals",children:"Set Literals"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto tags = {"urgent", "important", "review"}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"type-inference-1",children:"Type Inference"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto nums = {1, 2, 3}           // set<int>\nauto strs = {"a", "b", "c"}     // set<string>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"lambda-expressions",children:"Lambda Expressions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto square = func(int n) returns int {\n    return n * n\n}\n\nauto add = func(int a, int b) {\n    return a + b\n}\n\n// Type: func(int, int) -> int\n"})}),"\n",(0,r.jsx)(n.h3,{id:"lambda-capture",children:"Lambda Capture"}),"\n",(0,r.jsx)(n.p,{children:"Lambdas capture variables from enclosing scope:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto multiplier = 10\nauto times10 = func(int x) returns int {\n    return x * multiplier  // Captures multiplier\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"enum-instantiation",children:"Enum Instantiation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"enum Option<T> {\n    Some(T)\n    None\n}\n\nauto opt = Option<int>.Some(42)\nauto none = Option<int>.None\nauto inferred = Some(42)  // Type inferred from context\n"})}),"\n",(0,r.jsx)(n.h2,{id:"class-instantiation",children:"Class Instantiation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"class Circle {\n    float radius\n\n    func new(float r) returns void {\n        self.radius = r\n    }\n}\n\nauto c = Circle.new(5.0)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"generic-classes",children:"Generic Classes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"class Stack<T> {\n    list<T> items\n}\n\nauto int_stack = Stack<int>.new()\nauto str_stack = Stack<string>.new()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"member-access",children:"Member Access"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto r = circle.radius           // Field access\nauto len = str.size()            // Method call\nauto elem = list[0]              // Array access\n"})}),"\n",(0,r.jsx)(n.h3,{id:"field-access",children:"Field Access"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"class Point {\n    int x\n    int y\n}\n\nauto p = Point.new()\nauto x_coord = p.x  // Read field\np.x = 10            // Write to field\n"})}),"\n",(0,r.jsx)(n.h3,{id:"method-call",children:"Method Call"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto result = numbers.size()     // Method call\nauto upper = "hello".to_upper()  // Method on literal\n'})}),"\n",(0,r.jsx)(n.h2,{id:"arraylist-access",children:"Array/List Access"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto first = myList[0]           // Read element\nmyList[0] = 42                   // Write element\n\n// Out of bounds is runtime error\n// auto bad = myList[1000]        // Runtime error\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"safe-access-with-get",children:["Safe Access with ",(0,r.jsx)(n.code,{children:".get()"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'auto first = myList.get(0)       // Optional<int>\nmatch myList.get(0) {\n    Some(value) { print(value) }\n    None { print("out of bounds") }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"range-expressions",children:"Range Expressions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"auto nums = range(0, 10)  // list<int>: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"conditional-expressions",children:"Conditional Expressions"}),"\n",(0,r.jsxs)(n.p,{children:["Mux does not have a ternary ",(0,r.jsx)(n.code,{children:"? :"})," operator. Use ",(0,r.jsx)(n.code,{children:"if"}),"/",(0,r.jsx)(n.code,{children:"else"})," as a statement:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"// Not valid Mux:\n// auto x = condition ? 1 : 2\n\n// Instead:\nauto x = if condition {\n    1\n} else {\n    2\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"expression-statements",children:"Expression Statements"}),"\n",(0,r.jsx)(n.p,{children:"Expressions can be used as statements when side effects are desired:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'some_function()           // Function call\nx++                       // Increment\nx += 5                    // Compound assignment\nprint("message")          // Print for side effect\n'})}),"\n",(0,r.jsx)(n.h2,{id:"type-of-expressions",children:"Type of Expressions"}),"\n",(0,r.jsx)(n.p,{children:"The compiler determines the type of each expression:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Expression"}),(0,r.jsx)(n.th,{children:"Type"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Integer literal"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Float literal"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"String literal"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Boolean literal"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Tuple literal"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"tuple<T, U>"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"List literal"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"list<T>"})," (inferred)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Identifier"}),(0,r.jsx)(n.td,{children:"Declared or inferred type"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"a + b"})}),(0,r.jsxs)(n.td,{children:["Type of ",(0,r.jsx)(n.code,{children:"a"})," and ",(0,r.jsx)(n.code,{children:"b"})," (must match)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"a == b"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"a && b"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"!a"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"range(a, b)"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"list<int>"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Lambda"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"func(...) -> ..."})})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/reference/operators",children:"Operators"})," - Operator precedence"]}),"\n"]})]})}function x(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453(e,n,s){s.d(n,{R:()=>t,x:()=>a});var i=s(6540);const r={},l=i.createContext(r);function t(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);