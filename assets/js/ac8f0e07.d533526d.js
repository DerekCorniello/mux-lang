"use strict";(globalThis.webpackChunkmux_website=globalThis.webpackChunkmux_website||[]).push([[691],{2220(e,n,s){s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"language-guide/collections","title":"Collections","description":"Mux provides three main collection types: lists, maps, and sets, with Python-style literal syntax.","source":"@site/docs/language-guide/collections.md","sourceDirName":"language-guide","slug":"/language-guide/collections","permalink":"/docs/language-guide/collections","draft":false,"unlisted":false,"editUrl":"https://github.com/derekcorniello/mux-lang/tree/main/mux-website/docs/language-guide/collections.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Generics","permalink":"/docs/language-guide/generics"},"next":{"title":"Error Handling","permalink":"/docs/language-guide/error-handling"}}');var i=s(4848),r=s(8453);const l={},c="Collections",d={},o=[{value:"Lists",id:"lists",level:2},{value:"Creating Lists",id:"creating-lists",level:3},{value:"List Methods",id:"list-methods",level:3},{value:"List Operations",id:"list-operations",level:3},{value:"Iterating Lists",id:"iterating-lists",level:3},{value:"Maps",id:"maps",level:2},{value:"Creating Maps",id:"creating-maps",level:3},{value:"Map Methods",id:"map-methods",level:3},{value:"Map Operations",id:"map-operations",level:3},{value:"Sets",id:"sets",level:2},{value:"Creating Sets",id:"creating-sets",level:3},{value:"Set Methods",id:"set-methods",level:3},{value:"Set Operations",id:"set-operations",level:3},{value:"The <code>in</code> Operator",id:"the-in-operator",level:2},{value:"Nested Collections",id:"nested-collections",level:2},{value:"Collection Type Conversions",id:"collection-type-conversions",level:2},{value:"Generic Collections",id:"generic-collections",level:2},{value:"Collection Literals vs Constructors",id:"collection-literals-vs-constructors",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"collections",children:"Collections"})}),"\n",(0,i.jsx)(n.p,{children:"Mux provides three main collection types: lists, maps, and sets, with Python-style literal syntax."}),"\n",(0,i.jsx)(n.h2,{id:"lists",children:"Lists"}),"\n",(0,i.jsx)(n.p,{children:"Ordered, mutable collections of elements of the same type."}),"\n",(0,i.jsx)(n.h3,{id:"creating-lists",children:"Creating Lists"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="creating_lists.mux"',children:'// Explicit typing\nlist<int> nums = [1, 2, 3, 4]\nlist<string> names = ["Alice", "Bob", "Charlie"]\n\n// With type inference\nauto nums = [1, 2, 3, 4]           // inferred as list<int>\nauto names = ["Alice", "Bob"]      // inferred as list<string>\n\n// Empty list requires explicit type\nlist<int> empty = []\nauto empty2 = list<int>()\n\n// Nested lists\nlist<list<int>> matrix = [[1, 2], [3, 4]]\nauto matrix2 = [[1, 2], [3, 4]]    // inferred\n'})}),"\n",(0,i.jsx)(n.h3,{id:"list-methods",children:"List Methods"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Method"}),(0,i.jsx)(n.th,{children:"Returns"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".size()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})}),(0,i.jsx)(n.td,{children:"Number of elements in the list"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".is_empty()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bool"})}),(0,i.jsxs)(n.td,{children:["Returns ",(0,i.jsx)(n.code,{children:"true"})," if list has no elements"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".get(int index)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Optional<T>"})}),(0,i.jsxs)(n.td,{children:["Safe access; returns ",(0,i.jsx)(n.code,{children:"Some(value)"})," or ",(0,i.jsx)(n.code,{children:"None"})," if out of bounds"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"[int index]"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"T"})}),(0,i.jsx)(n.td,{children:"Direct access; runtime error if out of bounds"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".push(T item)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"void"})}),(0,i.jsx)(n.td,{children:"Appends item to the front"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".push_back(T item)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"void"})}),(0,i.jsx)(n.td,{children:"Appends item to the end"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".pop()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Optional<T>"})}),(0,i.jsxs)(n.td,{children:["Removes and returns first item, or ",(0,i.jsx)(n.code,{children:"None"})," if empty"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".pop_back()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Optional<T>"})}),(0,i.jsxs)(n.td,{children:["Removes and returns last item, or ",(0,i.jsx)(n.code,{children:"None"})," if empty"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".to_string()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsx)(n.td,{children:"String representation of the list"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"list-operations",children:"List Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="list_operations.mux"',children:'auto nums = [1, 2, 3]\n\n// Safe access with Optional\nmatch nums.get(0) {\n    Some(first) { print(first.to_string()) }  // "1"\n    None { print("Index out of bounds") }\n}\n\n// Direct access (runtime error if index invalid)\nauto second = nums[1]  // 2\n\n// Mutation\nnums.push_back(4)      // [1, 2, 3, 4]\nnums.push(5)           // [5, 1, 2, 3, 4]\n\nmatch nums.pop_back() {\n    Some(last) { print(last.to_string()) }  // "5"\n    None { }\n}\n\n// Inspection\nprint(nums.size().to_string())       // "4"\nprint(nums.is_empty().to_string())   // "false"\n\n// Concatenation\nauto list1 = [1, 2]\nauto list2 = [3, 4]\nauto combined = list1 + list2        // [1, 2, 3, 4]\n'})}),"\n",(0,i.jsx)(n.h3,{id:"iterating-lists",children:"Iterating Lists"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="iterating_lists.mux"',children:'auto items = [10, 20, 30, 40, 50]\n\n// For loop\nfor int item in items {\n    print(item.to_string())\n}\n\n// With indices using range\nfor int i in range(0, items.size()) {\n    auto item = items[i]\n    print("Index " + i.to_string() + ": " + item.to_string())\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"maps",children:"Maps"}),"\n",(0,i.jsx)(n.p,{children:"Key-value pairs with unique keys."}),"\n",(0,i.jsx)(n.h3,{id:"creating-maps",children:"Creating Maps"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="creating_maps.mux"',children:'// Explicit typing\nmap<string, int> scores = {"Alice": 90, "Bob": 85}\n\n// With type inference\nauto ages = {"Alice": 30, "Bob": 25}  // map<string, int>\n\n// Empty map requires explicit type\nmap<string, int> empty = {}\nauto empty2 = map<string, int>()\n\n// Nested maps\nmap<string, map<string, int>> data = {\n    "user1": {"score": 100, "level": 5},\n    "user2": {"score": 200, "level": 10}\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"map-methods",children:"Map Methods"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Method"}),(0,i.jsx)(n.th,{children:"Returns"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".size()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})}),(0,i.jsx)(n.td,{children:"Number of key-value pairs"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".is_empty()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bool"})}),(0,i.jsxs)(n.td,{children:["Returns ",(0,i.jsx)(n.code,{children:"true"})," if map has no entries"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".get(K key)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Optional<V>"})}),(0,i.jsxs)(n.td,{children:["Safe lookup; returns ",(0,i.jsx)(n.code,{children:"Some(value)"})," or ",(0,i.jsx)(n.code,{children:"None"})," if key not found"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"[K key]"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"V"})}),(0,i.jsx)(n.td,{children:"Direct access; runtime error if key not found"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".put(K key, V value)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"void"})}),(0,i.jsx)(n.td,{children:"Inserts or updates a key-value pair"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".contains(K key)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bool"})}),(0,i.jsxs)(n.td,{children:["Returns ",(0,i.jsx)(n.code,{children:"true"})," if key exists in map"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".remove(K key)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Optional<V>"})}),(0,i.jsxs)(n.td,{children:["Removes key and returns value, or ",(0,i.jsx)(n.code,{children:"None"})," if key not found"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".to_string()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsx)(n.td,{children:"String representation of the map"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".get_keys()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"list<K>"})}),(0,i.jsx)(n.td,{children:"List of keys from the map"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".get_values()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"list<V>"})}),(0,i.jsx)(n.td,{children:"List of values from the map"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".get_pairs()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"list<tuple<K, V>>"})}),(0,i.jsx)(n.td,{children:"List of key-value pairs"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"map-operations",children:"Map Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="map_operations.mux"',children:'auto scores = {"Alice": 90, "Bob": 85}\n\n// Safe access\nmatch scores.get("Alice") {\n    Some(score) { print(score.to_string()) }  // "90"\n    None { print("Student not found") }\n}\n\n// Direct access\nauto bobScore = scores["Bob"]  // 85\n\n// Update/insert\nscores.put("Alice", 95)\nscores["Charlie"] = 88\n\n// Check membership\nif scores.contains("Alice") {\n    print("Alice found")\n}\n\n// Remove\nmatch scores.remove("Bob") {\n    Some(value) { print("Removed Bob with score: " + value.to_string()) }\n    None { print("Bob not found") }\n}\n\n// Merge (latter wins on key collision)\nauto map1 = {"a": 1, "b": 2}\nauto map2 = {"b": 3, "c": 4}\nauto merged = map1 + map2        // {"a": 1, "b": 3, "c": 4}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"sets",children:"Sets"}),"\n",(0,i.jsx)(n.h3,{id:"creating-sets",children:"Creating Sets"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="creating_sets.mux"',children:'// Explicit typing\nset<int> numbers = {1, 2, 3, 4}\nset<string> tags = {"urgent", "important", "review"}\n\n// With type inference\nauto nums = {1, 2, 3}             // set<int> (requires all same type)\nauto words = {"hello", "world"}   // set<string>\n\n// Empty set requires explicit type\nset<int> empty = {}\nauto empty2 = set<int>()\n'})}),"\n",(0,i.jsx)(n.h3,{id:"set-methods",children:"Set Methods"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Method"}),(0,i.jsx)(n.th,{children:"Returns"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".size()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})}),(0,i.jsx)(n.td,{children:"Number of elements"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".is_empty()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bool"})}),(0,i.jsxs)(n.td,{children:["Returns ",(0,i.jsx)(n.code,{children:"true"})," if set is empty"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".add(T item)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"void"})}),(0,i.jsx)(n.td,{children:"Adds an item to the set"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".contains(T item)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bool"})}),(0,i.jsxs)(n.td,{children:["Returns ",(0,i.jsx)(n.code,{children:"true"})," if item exists in set"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".remove(T item)"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Optional<T>"})}),(0,i.jsxs)(n.td,{children:["Removes item and returns it, or ",(0,i.jsx)(n.code,{children:"None"})," if not found"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".to_string()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"string"})}),(0,i.jsx)(n.td,{children:"String representation of the set"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".to_list()"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"list<T>"})}),(0,i.jsx)(n.td,{children:"Creates a list from the set"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"set-operations",children:"Set Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="set_operations.mux"',children:'auto tags = {"urgent", "important", "review"}\n\nprint(tags.size().to_string())  // "3"\n\n// Add and check membership\ntags.add("priority")\nif tags.contains("urgent") {\n    print("Has urgent tag")\n}\n\n// Remove item\nmatch tags.remove("review") {\n    Some(removed) { print("Removed: " + removed) }\n    None { print("Item not found") }\n}\n\n// Union\nauto set1 = {1, 2, 3}\nauto set2 = {3, 4, 5}\nauto unioned = set1 + set2       // {1, 2, 3, 4, 5}\n'})}),"\n",(0,i.jsxs)(n.h2,{id:"the-in-operator",children:["The ",(0,i.jsx)(n.code,{children:"in"})," Operator"]}),"\n",(0,i.jsx)(n.p,{children:"Test for membership/containment:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="in_operator.mux"',children:'// List containment\nauto nums = [1, 2, 3, 4, 5]\nauto hasThree = 3 in nums     // true\nauto hasTen = 10 in nums      // false\n\n// Set containment\nauto tags = {"urgent", "important"}\nauto isUrgent = "urgent" in tags    // true\n\n// String containment\nauto msg = "hello world"\nauto hasWorld = "world" in msg      // true\nauto hasFoo = "foo" in msg          // false\n\n// Character in string\nauto hasO = \'o\' in msg              // true\nauto hasZ = \'z\' in msg              // false\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Type Requirements:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Both operands must have compatible element types"}),"\n",(0,i.jsx)(n.li,{children:"No implicit type conversions allowed"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"nested-collections",children:"Nested Collections"}),"\n",(0,i.jsx)(n.p,{children:"Collections can be arbitrarily nested:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="nested_collections.mux"',children:'// List of maps\nauto users = [\n    {"name": "Alice", "age": 30},\n    {"name": "Bob", "age": 25}\n]\n\n// Map of lists\nauto data = {\n    "numbers": [1, 2, 3, 4, 5],\n    "names": ["Alice", "Bob", "Charlie"]\n}\n\n// Complex nested structure\nauto complex = {\n    "users": [\n        {"name": "Alice", "scores": [95, 87, 92]},\n        {"name": "Bob", "scores": [78, 85, 90]}\n    ]\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"collection-type-conversions",children:"Collection Type Conversions"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"No automatic conversions"})," - collections must have exact type match:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="collection_conversions.mux"',children:"// ERROR: Type mismatch\n// auto bad = [1, 2] + [3.0, 4.0]  // list<int> + list<float>\n\n// Correct: Explicit conversion\nauto ints = [1, 2]\nauto floats = [3.0, 4.0]\nauto ints_as_floats = [ints[0].to_float(), ints[1].to_float()]\nauto combined = ints_as_floats + floats  // list<float>\n"})}),"\n",(0,i.jsx)(n.h2,{id:"generic-collections",children:"Generic Collections"}),"\n",(0,i.jsx)(n.p,{children:"Collections work seamlessly with generics:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="generic_collections.mux"',children:'func first<T>(list<T> items) returns Optional<T> {\n    if items.is_empty() {\n        return None.new()\n    }\n    return Some.new(items[0])\n}\n\nfunc lookup<K, V>(map<K, V> data, K key) returns Optional<V> {\n    return data.get(key)\n}\n\n// Usage\nauto nums = [1, 2, 3]\nauto maybeFirst = first<int>(nums)\n\nauto scores = {"Alice": 90, "Bob": 85}\nauto aliceScore = lookup<string, int>(scores, "Alice")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"collection-literals-vs-constructors",children:"Collection Literals vs Constructors"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="collection_literals.mux"',children:'// Literal syntax (preferred when possible)\nauto nums = [1, 2, 3]\nauto scores = {"Alice": 90, "Bob": 85}\nauto tags = {"urgent", "important"}\n\n// Constructor syntax (required for empty collections with auto)\nauto empty_list = list<int>()\nauto empty_map = map<string, int>()\nauto empty_set = set<string>()\n\n// Explicit type with literal (empty collections)\nlist<int> nums = []\nmap<string, int> scores = {}\nset<string> tags = {}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use safe access methods"})," - ",(0,i.jsx)(n.code,{children:".get()"})," returns ",(0,i.jsx)(n.code,{children:"Optional<T>"})," to avoid runtime errors"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Explicit types for empty collections"})," - Prevents ambiguity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Leverage type inference"})," - Use ",(0,i.jsx)(n.code,{children:"auto"})," when types are obvious from literals"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Use the ",(0,i.jsx)(n.code,{children:"in"})," operator"]})," - Cleaner than calling ",(0,i.jsx)(n.code,{children:".contains()"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Prefer literals over constructors"})," - More readable"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use appropriate collection type"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"List"}),": Ordered, indexed access, duplicates allowed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Map"}),": Key-value pairs, unique keys"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Set"}),": Unique elements, membership testing"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Match on fallible operations"})," - Handle ",(0,i.jsx)(n.code,{children:"None"})," cases explicitly"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/language-guide/types",children:"Types"})," - Type system and conversions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/language-guide/generics",children:"Generics"})," - Generic functions with collections"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/language-guide/error-handling",children:"Error Handling"})," - Optional<T> for safe access"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/language-guide/memory",children:"Memory"})," - Reference counting for collections"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453(e,n,s){s.d(n,{R:()=>l,x:()=>c});var t=s(6540);const i={},r=t.createContext(i);function l(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);