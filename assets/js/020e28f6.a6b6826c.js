"use strict";(globalThis.webpackChunkmux_website=globalThis.webpackChunkmux_website||[]).push([[866],{5189(n,e,t){t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"language-guide/control-flow","title":"Control Flow","description":"Mux provides familiar control flow constructs with some unique features like pattern matching with guards.","source":"@site/docs/language-guide/control-flow.md","sourceDirName":"language-guide","slug":"/language-guide/control-flow","permalink":"/docs/language-guide/control-flow","draft":false,"unlisted":false,"editUrl":"https://github.com/derekcorniello/mux-lang/tree/main/mux-website/docs/language-guide/control-flow.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Functions","permalink":"/docs/language-guide/functions"},"next":{"title":"Classes","permalink":"/docs/language-guide/classes"}}');var r=t(4848),a=t(8453);const s={},l="Control Flow",o={},c=[{value:"If / Else",id:"if--else",level:2},{value:"If as an Expression",id:"if-as-an-expression",level:3},{value:"For Loops",id:"for-loops",level:2},{value:"Ignoring Loop Variables",id:"ignoring-loop-variables",level:3},{value:"Iterating Collections",id:"iterating-collections",level:3},{value:"While Loops",id:"while-loops",level:2},{value:"Break and Continue",id:"break-and-continue",level:2},{value:"Match Statements",id:"match-statements",level:2},{value:"Basic Matching",id:"basic-matching",level:3},{value:"Matching Optional",id:"matching-optional",level:3},{value:"Matching Result",id:"matching-result",level:3},{value:"Pattern Matching with Guards",id:"pattern-matching-with-guards",level:3},{value:"Ignoring Values in Patterns",id:"ignoring-values-in-patterns",level:3},{value:"Matching Enums",id:"matching-enums",level:3},{value:"Wildcard Pattern",id:"wildcard-pattern",level:3},{value:"Exhaustive Matching",id:"exhaustive-matching",level:3},{value:"Match as Switch Statement",id:"match-as-switch-statement",level:3},{value:"Variable Binding in Switch Patterns",id:"variable-binding-in-switch-patterns",level:4},{value:"Constants in Switch Patterns",id:"constants-in-switch-patterns",level:4},{value:"List Literal Matching",id:"list-literal-matching",level:4},{value:"Switch with Guards",id:"switch-with-guards",level:4},{value:"Return Statement",id:"return-statement",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"control-flow",children:"Control Flow"})}),"\n",(0,r.jsx)(e.p,{children:"Mux provides familiar control flow constructs with some unique features like pattern matching with guards."}),"\n",(0,r.jsx)(e.h2,{id:"if--else",children:"If / Else"}),"\n",(0,r.jsx)(e.p,{children:"Standard if-else branching with curly braces:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="if_else.mux"',children:'if x > 0 {\n    print("positive")\n} else if x < 0 {\n    print("negative")\n} else {\n    print("zero")\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"if-as-an-expression",children:"If as an Expression"}),"\n",(0,r.jsxs)(e.p,{children:["In Mux, ",(0,r.jsx)(e.code,{children:"if"})," can be used as an expression that returns a value:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="if_expression.mux"',children:'auto message = if x > 0 { "positive" } else { "non-positive" }\n\nauto status = if score >= 90 {\n    "excellent"\n} else if score >= 70 {\n    "good"\n} else {\n    "needs improvement"\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"for-loops",children:"For Loops"}),"\n",(0,r.jsxs)(e.p,{children:["Mux uses range-based for loops only (no C-style ",(0,r.jsx)(e.code,{children:"for (int i = 0; i < n; i++)"}),"):"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="for_loops.mux"',children:'// Iterating over a list\nauto items = [1, 2, 3, 4, 5]\nfor int item in items {\n    print(item.to_string())\n}\n\n// Using range() for numeric iteration\nfor int i in range(0, 10) {\n    print("Iteration: " + i.to_string())\n}\n\n// Explicit typing for clarity\nauto collection = ["Bob", "Alice", "Eve"]\nfor string name in collection {\n    auto processed = create_message_to(name)\n    print(processed)\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"ignoring-loop-variables",children:"Ignoring Loop Variables"}),"\n",(0,r.jsxs)(e.p,{children:["Use ",(0,r.jsx)(e.code,{children:"_"})," when you don't need the loop variable:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="ignoring_loop_vars.mux"',children:"// Execute 10 times, don't care about index\nfor int _ in range(0, 10) {\n    doSomething()\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"iterating-collections",children:"Iterating Collections"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="iterating_collections.mux"',children:'// List iteration\nauto nums = [10, 20, 30]\nfor int n in nums {\n    print(n.to_string())\n}\n\nauto myMap = {\n    "a": 1,\n    "b": 2,\n    "c": 3\n}\n// Map iteration on keys\nfor key in myMap.keys() {\n    print(key)\n}\n\n// Map iteration on vals\nfor value in myMap.keys() {\n    print(value)\n}\n\nauto mySet = {"a", "b", "c"}\nfor char in mySet {\n    print(char.to_string())\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"while-loops",children:"While Loops"}),"\n",(0,r.jsx)(e.p,{children:"Standard while loops with boolean conditions:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="while_loops.mux"',children:"auto count = 0\nwhile count < 10 {\n    print(count.to_string())\n    count++\n}\n\n// With type inference for locals\nwhile condition {\n    auto currentTime = getCurrentTime()\n    if currentTime > threshold {\n        break\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"break-and-continue",children:"Break and Continue"}),"\n",(0,r.jsx)(e.p,{children:"Control loop execution:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="break_continue.mux"',children:"// Break exits the loop\nfor int i in range(0, 100) {\n    if i > 10 {\n        break\n    }\n    print(i.to_string())\n}\n\n// Continue skips to next iteration\nfor int i in range(0, 10) {\n    if i % 2 == 0 {\n        continue  // skip even numbers\n    }\n    print(i.to_string())\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"match-statements",children:"Match Statements"}),"\n",(0,r.jsx)(e.p,{children:"Pattern matching with guards and destructuring:"}),"\n",(0,r.jsx)(e.h3,{id:"basic-matching",children:"Basic Matching"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="basic_matching.mux"',children:'match value {\n    1 {\n        print("one")\n    }\n    2 {\n        print("two")\n    }\n    _ {\n        print("other")  // wildcard pattern\n    }\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"This is equivalent to:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="if_else_equivalent.mux"',children:'if value == 1 {\n    print("one")\n} else if value == 2 {\n    print("two")\n} else {\n    print("other")\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"matching-optional",children:"Matching Optional"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="matching_optional.mux"',children:'func findEven(list<int> xs) returns Optional<int> {\n    for x in xs {\n        if x % 2 == 0 {\n            return Some(x)\n        }\n    }\n    return None\n}\n\nauto maybeEven = findEven([1, 3, 4, 7])\n\nmatch maybeEven {\n    Some(value) {\n        print("Found even: " + value.to_string())\n    }\n    None {\n        print("No even number found")\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"matching-result",children:"Matching Result"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="matching_result.mux"',children:'func divide(int a, int b) returns Result<int, string> {\n    if b == 0 {\n        return Err("division by zero")\n    }\n    return Ok(a / b)\n}\n\nauto result = divide(10, 2)\n\nmatch result {\n    Ok(value) {\n        print("Result: " + value.to_string())\n    }\n    Err(error) {\n        print("Error: " + error)\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"pattern-matching-with-guards",children:"Pattern Matching with Guards"}),"\n",(0,r.jsx)(e.p,{children:"Guards add conditional logic to patterns:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="pattern_guards.mux"',children:'match value {\n    Some(v) if v > 10 {\n        print("large: " + v.to_string())\n    }\n    Some(v) if v > 0 {\n        print("small positive: " + v.to_string())\n    }\n    Some(v) {\n        print("non-positive: " + v.to_string())\n    }\n    None {\n        print("no value")\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"ignoring-values-in-patterns",children:"Ignoring Values in Patterns"}),"\n",(0,r.jsxs)(e.p,{children:["Use ",(0,r.jsx)(e.code,{children:"_"})," to ignore parts of patterns you don't need:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="pattern_ignore.mux"',children:'// Ignore the wrapped value\nmatch maybeValue {\n    Some(_) {\n        print("Got a value")  // don\'t care what it is\n    }\n    None {\n        print("Got nothing")\n    }\n}\n\n// Ignore error details\nmatch result {\n    Ok(value) {\n        print("Success: " + value.to_string())\n    }\n    Err(_) {\n        print("Some error occurred")  // don\'t care about details\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"matching-enums",children:"Matching Enums"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="matching_enums.mux"',children:'enum Shape {\n    Circle(float radius)\n    Rectangle(float width, float height)\n    Square(float size)\n}\n\nauto myShape = Circle.new(5.0)\n\nmatch myShape {\n    Circle(r) {\n        print("Circle with radius: " + r.to_string())\n    }\n    Rectangle(w, h) {\n        print("Rectangle: " + w.to_string() + "x" + h.to_string())\n    }\n    Square(s) {\n        print("Square with size: " + s.to_string())\n    }\n}\n\n// Ignoring enum data\nmatch shape {\n    Circle(_) {\n        print("It\'s a circle")  // radius ignored\n    }\n    Rectangle(width, _) {\n        print("Rectangle with width: " + width.to_string())  // height ignored\n    }\n    Square(size) {\n        print("Square with size: " + size.to_string())\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"wildcard-pattern",children:"Wildcard Pattern"}),"\n",(0,r.jsxs)(e.p,{children:["The ",(0,r.jsx)(e.code,{children:"_"})," pattern matches anything:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="wildcard_pattern.mux"',children:'match status {\n    0 { print("success") }\n    1 { print("warning") }\n    2 { print("error") }\n    _ { print("unknown status") }  // catch-all\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"exhaustive-matching",children:"Exhaustive Matching"}),"\n",(0,r.jsx)(e.p,{children:"Mux requires that all possible cases are handled in a match statement. If you miss a case, the compiler will give an error:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="exhaustive_matching.mux"',children:'match value {\n    1 { print("one") }\n    2 { print("two") }\n    // Missing wildcard or other cases will cause a compile error!\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"match-as-switch-statement",children:"Match as Switch Statement"}),"\n",(0,r.jsx)(e.p,{children:"Match statements can be used as switch statements for any type, not just enums:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="switch_on_primitives.mux"',children:'// Match on int literals (like a switch)\nauto status = 200\nmatch status {\n    200 { print("OK") }\n    404 { print("Not Found") }\n    500 { print("Server Error") }\n    _ { print("Unknown status") }\n}\n\n// Match on string literals\nauto command = "start"\nmatch command {\n    "start" { print("Starting...") }\n    "stop" { print("Stopping...") }\n    "restart" { print("Restarting...") }\n    _ { print("Unknown command") }\n}\n\n// Match on bool values\nauto flag = true\nmatch flag {\n    true { print("Enabled") }\n    false { print("Disabled") }\n}\n\n// Match on char literals\nauto letter = \'a\'\nmatch letter {\n    \'a\' { print("Alpha") }\n    \'b\' { print("Bravo") }\n    _ { print("Other") }\n}\n'})}),"\n",(0,r.jsx)(e.h4,{id:"variable-binding-in-switch-patterns",children:"Variable Binding in Switch Patterns"}),"\n",(0,r.jsx)(e.p,{children:"Capture matched values in variables:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="switch_variable_binding.mux"',children:'auto value = 42\nmatch value {\n    1 { print("one") }\n    captured { print("got: " + captured.to_string()) }\n    _ { print("shouldn\'t reach here") }\n}\n\n// With strings\nauto name = "world"\nmatch name {\n    "admin" { print("Hello, admin!") }\n    n { print("Hello, " + n) }\n}\n'})}),"\n",(0,r.jsx)(e.h4,{id:"constants-in-switch-patterns",children:"Constants in Switch Patterns"}),"\n",(0,r.jsx)(e.p,{children:"Use constants as match patterns:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="switch_constants.mux"',children:'const int ADMIN = 1\nconst int MODERATOR = 2\nauto level = 1\nmatch level {\n    ADMIN { print("admin") }\n    MODERATOR { print("moderator") }\n    _ { print("user") }\n}\n'})}),"\n",(0,r.jsx)(e.h4,{id:"list-literal-matching",children:"List Literal Matching"}),"\n",(0,r.jsx)(e.p,{children:"Match on list structure:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="switch_list_matching.mux"',children:'auto nums = [1, 2, 3]\nmatch nums {\n    [] { print("empty") }\n    [1] { print("single: 1") }\n    [1, 2] { print("two: 1, 2") }\n    [1, 2, 3] { print("three: 1, 2, 3") }\n    [first, ..rest] { print("has elements") }\n    _ { print("weird list") }\n}\n'})}),"\n",(0,r.jsx)(e.h4,{id:"switch-with-guards",children:"Switch with Guards"}),"\n",(0,r.jsx)(e.p,{children:"Add conditions to switch cases:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="switch_with_guards.mux"',children:'auto score = 85\nmatch score {\n    n if n >= 90 { print("A") }\n    n if n >= 80 { print("B") }\n    n if n >= 70 { print("C") }\n    n if n >= 60 { print("D") }\n    _ { print("F") }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"return-statement",children:"Return Statement"}),"\n",(0,r.jsx)(e.p,{children:"Exit a function early:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mux",metastring:'title="return_statement.mux"',children:'func findFirst(list<int> items, int target) returns Optional<int> {\n    for i in range(0, items.size()) {\n        if items[i] == target {\n            return Some(i)  // early return\n        }\n    }\n    return None\n}\n\nfunc validate(int value) returns Result<int, string> {\n    if value < 0 {\n        return Err("value must be positive")\n    }\n    if value > 100 {\n        return Err("value too large")\n    }\n    return Ok(value)\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsxs)(e.strong,{children:["Use ",(0,r.jsx)(e.code,{children:"match"})," for Result and Optional"]})," - More expressive than if-else chains"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Prefer pattern matching with guards"})," - Cleaner than nested if statements"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsxs)(e.strong,{children:["Use ",(0,r.jsx)(e.code,{children:"_"})," for unused values"]})," - Makes intent explicit"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Early returns for error conditions"})," - Reduces nesting"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsxs)(e.strong,{children:["Use ",(0,r.jsx)(e.code,{children:"range()"})," for numeric loops"]})," - Idiomatic Mux"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Break and continue judiciously"})," - Can make code harder to follow if overused"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/docs/language-guide/error-handling",children:"Error Handling"})," - Using Result and Optional with match"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/docs/language-guide/enums",children:"Enums"})," - Pattern matching with tagged unions"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/docs/language-guide/functions",children:"Functions"})," - Return statements and early exits"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"/docs/language-guide/variables",children:"Variables"})," - Type inference with ",(0,r.jsx)(e.code,{children:"auto"})]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453(n,e,t){t.d(e,{R:()=>s,x:()=>l});var i=t(6540);const r={},a=i.createContext(r);function s(n){const e=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);