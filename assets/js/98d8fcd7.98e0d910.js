"use strict";(globalThis.webpackChunkmux_website=globalThis.webpackChunkmux_website||[]).push([[634],{6996(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"reference/abi","title":"ABI (Application Binary Interface)","description":"This document describes the binary interface for Mux, including calling conventions, type representations, and interoperability.","source":"@site/docs/reference/abi.md","sourceDirName":"reference","slug":"/reference/abi","permalink":"/docs/reference/abi","draft":false,"unlisted":false,"editUrl":"https://github.com/derekcorniello/mux-lang/tree/main/mux-website/docs/reference/abi.md","tags":[],"version":"current","frontMatter":{}}');var r=i(4848),l=i(8453);const s={},d="ABI (Application Binary Interface)",c={},a=[{value:"Warning",id:"warning",level:2},{value:"Calling Convention",id:"calling-convention",level:2},{value:"Argument Passing",id:"argument-passing",level:3},{value:"Return Values",id:"return-values",level:3},{value:"Type Representations",id:"type-representations",level:2},{value:"Primitive Types",id:"primitive-types",level:3},{value:"Composite Types",id:"composite-types",level:3},{value:"Optional&lt;T&gt;",id:"optionalt",level:4},{value:"Result&lt;T, E&gt;",id:"resultt-e",level:4},{value:"list&lt;T&gt;",id:"listt",level:4},{value:"map&lt;K, V&gt;",id:"mapk-v",level:4},{value:"set&lt;T&gt;",id:"sett",level:4},{value:"Value Representation",id:"value-representation",level:2},{value:"Boxed Values",id:"boxed-values",level:3},{value:"Name Mangling",id:"name-mangling",level:2},{value:"Function Names",id:"function-names",level:3},{value:"Examples",id:"examples",level:3},{value:"Operator Overloads",id:"operator-overloads",level:3},{value:"Runtime Functions",id:"runtime-functions",level:2},{value:"Memory Management",id:"memory-management",level:3},{value:"Value Operations",id:"value-operations",level:3},{value:"String Operations",id:"string-operations",level:3},{value:"Collection Operations",id:"collection-operations",level:3},{value:"Symbol Names",id:"symbol-names",level:2},{value:"Exported Symbols",id:"exported-symbols",level:3},{value:"Object File Format",id:"object-file-format",level:3},{value:"C Interoperability",id:"c-interoperability",level:2},{value:"Declaring C Functions",id:"declaring-c-functions",level:3},{value:"Limitations",id:"limitations",level:3},{value:"Future ABI Stability",id:"future-abi-stability",level:2},{value:"See Also",id:"see-also",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"abi-application-binary-interface",children:"ABI (Application Binary Interface)"})}),"\n",(0,r.jsx)(n.p,{children:"This document describes the binary interface for Mux, including calling conventions, type representations, and interoperability."}),"\n",(0,r.jsx)(n.h2,{id:"warning",children:"Warning"}),"\n",(0,r.jsx)(n.p,{children:"The ABI is not yet stable. This document describes the current implementation, which may change."}),"\n",(0,r.jsx)(n.h2,{id:"calling-convention",children:"Calling Convention"}),"\n",(0,r.jsx)(n.p,{children:"Mux uses the System V AMD64 ABI on Linux/x86-64, with the following modifications:"}),"\n",(0,r.jsx)(n.h3,{id:"argument-passing",children:"Argument Passing"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Passing Method"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})}),(0,r.jsx)(n.td,{children:"Register (RDI, RSI, RDX, RCX, R8, R9) or stack"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})}),(0,r.jsx)(n.td,{children:"Register (XMM0-XMM7) or stack"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})}),(0,r.jsx)(n.td,{children:"Register (as 8-bit value)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"char"})}),(0,r.jsx)(n.td,{children:"Register (as 8-bit value)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:"Register (pointer to struct)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"list&lt;T>"}),", ",(0,r.jsx)(n.code,{children:"map&lt;K,V>"}),", ",(0,r.jsx)(n.code,{children:"set&lt;T>"})]}),(0,r.jsx)(n.td,{children:"Register (pointer to struct)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"Optional&lt;T>"}),", ",(0,r.jsx)(n.code,{children:"Result&lt;T,E>"})]}),(0,r.jsx)(n.td,{children:"Register (pointer to struct)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Class instances"}),(0,r.jsx)(n.td,{children:"Register (pointer to object)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:["References (",(0,r.jsx)(n.code,{children:"&T"}),")"]}),(0,r.jsx)(n.td,{children:"Register (pointer)"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"return-values",children:"Return Values"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Return Method"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"void"})}),(0,r.jsx)(n.td,{children:"No return value"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"int"}),", ",(0,r.jsx)(n.code,{children:"float"}),", ",(0,r.jsx)(n.code,{children:"bool"}),", ",(0,r.jsx)(n.code,{children:"char"})]}),(0,r.jsx)(n.td,{children:"Register (RAX or XMM0)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:"Pointer in RAX, length in RDX"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"list&lt;T>"}),", ",(0,r.jsx)(n.code,{children:"map&lt;K,V>"}),", ",(0,r.jsx)(n.code,{children:"set&lt;T>"})]}),(0,r.jsx)(n.td,{children:"Pointer to struct in RAX"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"Optional&lt;T>"}),", ",(0,r.jsx)(n.code,{children:"Result&lt;T,E>"})]}),(0,r.jsx)(n.td,{children:"Pointer to struct in RAX"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Class instances"}),(0,r.jsx)(n.td,{children:"Pointer to object in RAX"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:["References (",(0,r.jsx)(n.code,{children:"&T"}),")"]}),(0,r.jsx)(n.td,{children:"Pointer in RAX"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"type-representations",children:"Type Representations"}),"\n",(0,r.jsx)(n.h3,{id:"primitive-types",children:"Primitive Types"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Mux Type"}),(0,r.jsx)(n.th,{children:"C Type"}),(0,r.jsx)(n.th,{children:"Size"}),(0,r.jsx)(n.th,{children:"Alignment"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"void"})}),(0,r.jsx)(n.td,{children:"void"}),(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"1"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})}),(0,r.jsx)(n.td,{children:"int64_t"}),(0,r.jsx)(n.td,{children:"8"}),(0,r.jsx)(n.td,{children:"8"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})}),(0,r.jsx)(n.td,{children:"double"}),(0,r.jsx)(n.td,{children:"8"}),(0,r.jsx)(n.td,{children:"8"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})}),(0,r.jsx)(n.td,{children:"uint8_t"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"1"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"char"})}),(0,r.jsx)(n.td,{children:"uint32_t"}),(0,r.jsx)(n.td,{children:"4"}),(0,r.jsx)(n.td,{children:"4"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:"struct { void* ptr; int64_t len; }"}),(0,r.jsx)(n.td,{children:"16"}),(0,r.jsx)(n.td,{children:"8"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"composite-types",children:"Composite Types"}),"\n",(0,r.jsx)(n.h4,{id:"optionalt",children:"Optional<T>"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"struct Optional<T> {\n    int32_t discriminant;  // 0 = None, 1 = Some\n    void* data;           // Pointer to T\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"resultt-e",children:"Result<T, E>"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"struct Result<T, E> {\n    int32_t discriminant;  // 0 = Ok, 1 = Err\n    void* data;           // Pointer to T or E\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"listt",children:"list<T>"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"struct list<T> {\n    void** data;      // Pointer to array of Value*\n    int64_t size;     // Number of elements\n    int64_t capacity;  // Allocated capacity\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"mapk-v",children:"map<K, V>"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"struct map<K, V> {\n    void* tree;       // Pointer to BTreeMap\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"sett",children:"set<T>"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"struct set<T> {\n    void* tree;       // Pointer to BTreeSet\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"value-representation",children:"Value Representation"}),"\n",(0,r.jsxs)(n.p,{children:["All runtime values are represented using the ",(0,r.jsx)(n.code,{children:"Value"})," enum:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"enum Value {\n    Bool(bool),\n    Int(i64),\n    Float(f64),\n    String(String),\n    List(Vec<Value>),\n    Map(BTreeMap<Value, Value>),\n    Set(BTreeSet<Value>),\n    Optional(Option<Box<Value>>),\n    Result(Result<Box<Value>, String>),\n    Object(ObjectRef),\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"boxed-values",children:"Boxed Values"}),"\n",(0,r.jsxs)(n.p,{children:["Primitive values are boxed into ",(0,r.jsx)(n.code,{children:"*mut Value"})," pointers:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   RefHeader      \u2502    Value    \u2502\n\u2502 ref_count: u64   \u2502  discriminator + data |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h2,{id:"name-mangling",children:"Name Mangling"}),"\n",(0,r.jsx)(n.h3,{id:"function-names",children:"Function Names"}),"\n",(0,r.jsx)(n.p,{children:"Functions are mangled to encode their module and signature:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"module_functionName$paramType1$paramType2$...\n"})}),"\n",(0,r.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"// math.mux\nfunc fibonacci(int n) returns int { ... }\n// Mangled: math_fibonacci$$int\n\n// main.mux\nfunc add(int a, int b) returns int { ... }\n// Mangled: main_add$$int$$int\n\n// Generic functions\nfunc identity<T>(T value) returns T { ... }\n// identity$$int\n// identity$$string\n"})}),"\n",(0,r.jsx)(n.h3,{id:"operator-overloads",children:"Operator Overloads"}),"\n",(0,r.jsx)(n.p,{children:"Operator methods use the interface name:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"class Point {\n    func add(Point other) returns Point { ... }\n}\n// Mangled: Point_add$Point\n"})}),"\n",(0,r.jsx)(n.h2,{id:"runtime-functions",children:"Runtime Functions"}),"\n",(0,r.jsx)(n.p,{children:"The Mux runtime provides the following functions for FFI:"}),"\n",(0,r.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"void* mux_rc_alloc(Value value);\nvoid mux_rc_inc(void* ptr);\nbool mux_rc_dec(void* ptr);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"value-operations",children:"Value Operations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"int64_t mux_value_get_int(void* ptr);\nvoid mux_value_set_int(void* ptr, int64_t value);\ndouble mux_value_get_float(void* ptr);\nvoid mux_value_set_float(void* ptr, double value);\nconst char* mux_value_get_string(void* ptr);\n// ... and more\n"})}),"\n",(0,r.jsx)(n.h3,{id:"string-operations",children:"String Operations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"void* mux_string_create(const char* str);\nvoid* mux_string_concat(void* a, void* b);\nint64_t mux_string_length(void* ptr);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"collection-operations",children:"Collection Operations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"void* mux_list_create();\nvoid mux_list_push(void* list, void* value);\nvoid* mux_list_pop(void* list);\nvoid* mux_list_get(void* list, int64_t index);\n// ... and more\n"})}),"\n",(0,r.jsx)(n.h2,{id:"symbol-names",children:"Symbol Names"}),"\n",(0,r.jsx)(n.h3,{id:"exported-symbols",children:"Exported Symbols"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Symbol"}),(0,r.jsx)(n.th,{children:"Purpose"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"mux_main"})}),(0,r.jsx)(n.td,{children:"Program entry point"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"mux_init_module_<name>"})}),(0,r.jsx)(n.td,{children:"Module initialization"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"mux_rc_alloc"})}),(0,r.jsx)(n.td,{children:"Allocate RC value"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"mux_rc_inc"})}),(0,r.jsx)(n.td,{children:"Increment reference count"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"mux_rc_dec"})}),(0,r.jsx)(n.td,{children:"Decrement reference count"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"mux_print"})}),(0,r.jsx)(n.td,{children:"Print string to stdout"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"object-file-format",children:"Object File Format"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Object files: ELF64 (Linux), Mach-O (macOS), COFF (Windows)"}),"\n",(0,r.jsx)(n.li,{children:"Final executable: Platform-native format"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"c-interoperability",children:"C Interoperability"}),"\n",(0,r.jsx)(n.h3,{id:"declaring-c-functions",children:"Declaring C Functions"}),"\n",(0,r.jsx)(n.p,{children:"Mux can call C functions through runtime binding:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"// C header (example)\nint c_add(int a, int b);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"limitations",children:"Limitations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Limited FFI support in current version"}),"\n",(0,r.jsx)(n.li,{children:"C interop requires manual binding"}),"\n",(0,r.jsx)(n.li,{children:"Type marshaling is manual"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"future-abi-stability",children:"Future ABI Stability"}),"\n",(0,r.jsx)(n.p,{children:"The ABI will stabilize before version 1.0. Until then:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No guarantees about binary compatibility"}),"\n",(0,r.jsx)(n.li,{children:"Recompilation required between versions"}),"\n",(0,r.jsx)(n.li,{children:"Internal representations may change"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/reference/memory-model",children:"Memory Model"})," - Memory layout details"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/reference/type-system",children:"Type System"})," - Type representations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://github.com/derekcorniello/mux-lang",children:"Source Code"})," - Compiler implementation"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453(e,n,i){i.d(n,{R:()=>s,x:()=>d});var t=i(6540);const r={},l=t.createContext(r);function s(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);