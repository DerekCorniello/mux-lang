"use strict";(globalThis.webpackChunkmux_website=globalThis.webpackChunkmux_website||[]).push([[638],{2089(e,n,r){r.r(n),r.d(n,{assets:()=>t,contentTitle:()=>d,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>o});const c=JSON.parse('{"id":"reference/memory-model","title":"Memory Model","description":"Mux uses reference counting for deterministic memory management. This document describes the memory model in detail.","source":"@site/docs/reference/memory-model.md","sourceDirName":"reference","slug":"/reference/memory-model","permalink":"/docs/reference/memory-model","draft":false,"unlisted":false,"editUrl":"https://github.com/derekcorniello/mux-lang/tree/main/mux-website/docs/reference/memory-model.md","tags":[],"version":"current","frontMatter":{}}');var l=r(4848),s=r(8453);const i={},d="Memory Model",t={},o=[{value:"Overview",id:"overview",level:2},{value:"Memory Layout",id:"memory-layout",level:2},{value:"Heap Allocation",id:"heap-allocation",level:3},{value:"RefHeader Structure",id:"refheader-structure",level:3},{value:"Value Types",id:"value-types",level:3},{value:"Reference Counting Operations",id:"reference-counting-operations",level:2},{value:"Increment (<code>mux_rc_inc the reference count when</code>)",id:"increment-mux_rc_inc-the-reference-count-when",level:3},{value:"Decrement (<code>mux_rc_dec</code>)",id:"decrement-mux_rc_dec",level:3},{value:"Cleanup",id:"cleanup",level:3},{value:"Scope-Based Tracking",id:"scope-based-tracking",level:2},{value:"Example: Scope Cleanup",id:"example-scope-cleanup",level:3},{value:"Early Returns",id:"early-returns",level:3},{value:"Collections and Memory",id:"collections-and-memory",level:2},{value:"Nested Collections",id:"nested-collections",level:3},{value:"Circular References",id:"circular-references",level:2},{value:"Value Semantics",id:"value-semantics",level:2},{value:"Reference vs Value",id:"reference-vs-value",level:3},{value:"References (<code>&amp;T</code>)",id:"references-t",level:2},{value:"Reference Rules",id:"reference-rules",level:3},{value:"Memory Safety",id:"memory-safety",level:2},{value:"No Use-After-Free",id:"no-use-after-free",level:3},{value:"No Double-Free",id:"no-double-free",level:3},{value:"No Memory Leaks (Except Cycles)",id:"no-memory-leaks-except-cycles",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Thread Safety",id:"thread-safety",level:3},{value:"Comparison to Other Models",id:"comparison-to-other-models",level:2},{value:"See Also",id:"see-also",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"memory-model",children:"Memory Model"})}),"\n",(0,l.jsx)(n.p,{children:"Mux uses reference counting for deterministic memory management. This document describes the memory model in detail."}),"\n",(0,l.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,l.jsxs)(n.p,{children:["Mux provides ",(0,l.jsx)(n.strong,{children:"automatic memory management"})," through ",(0,l.jsx)(n.strong,{children:"atomic reference counting (RC)"}),":"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["No manual ",(0,l.jsx)(n.code,{children:"free"})," or ",(0,l.jsx)(n.code,{children:"delete"})]}),"\n",(0,l.jsx)(n.li,{children:"No garbage collector pauses"}),"\n",(0,l.jsx)(n.li,{children:"Deterministic cleanup when references go out of scope"}),"\n",(0,l.jsx)(n.li,{children:"Thread-safe reference count operations"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"memory-layout",children:"Memory Layout"}),"\n",(0,l.jsx)(n.h3,{id:"heap-allocation",children:"Heap Allocation"}),"\n",(0,l.jsx)(n.p,{children:"All non-primitive values are heap-allocated:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   RefHeader      \u2502    Value    \u2502\n\u2502 ref_count: u64   \u2502  (payload) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2191\n      Allocation pointer\n"})}),"\n",(0,l.jsx)(n.h3,{id:"refheader-structure",children:"RefHeader Structure"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"struct RefHeader {\n    ref_count: AtomicUsize,  // Thread-safe reference count\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"value-types",children:"Value Types"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Type"}),(0,l.jsx)(n.th,{children:"Storage"}),(0,l.jsx)(n.th,{children:"Memory Management"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsxs)(n.td,{children:[(0,l.jsx)(n.code,{children:"int"}),", ",(0,l.jsx)(n.code,{children:"float"}),", ",(0,l.jsx)(n.code,{children:"bool"}),", ",(0,l.jsx)(n.code,{children:"char"})]}),(0,l.jsxs)(n.td,{children:["Inline (boxed in ",(0,l.jsx)(n.code,{children:"Value"})," enum)"]}),(0,l.jsx)(n.td,{children:"Reference counted"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"string"})}),(0,l.jsx)(n.td,{children:"Heap-allocated UTF-8"}),(0,l.jsx)(n.td,{children:"Reference counted"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"list<T>"})}),(0,l.jsx)(n.td,{children:"Heap-allocated vector"}),(0,l.jsx)(n.td,{children:"Reference counted"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"map<K,V>"})}),(0,l.jsx)(n.td,{children:"Heap-allocated BTreeMap"}),(0,l.jsx)(n.td,{children:"Reference counted"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"set<T>"})}),(0,l.jsx)(n.td,{children:"Heap-allocated BTreeSet"}),(0,l.jsx)(n.td,{children:"Reference counted"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsxs)(n.td,{children:[(0,l.jsx)(n.code,{children:"Optional<T>"}),", ",(0,l.jsx)(n.code,{children:"Result<T,E>"})]}),(0,l.jsx)(n.td,{children:"Boxed enum"}),(0,l.jsx)(n.td,{children:"Reference counted"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Class instances"}),(0,l.jsx)(n.td,{children:"Heap-allocated object"}),(0,l.jsx)(n.td,{children:"Reference counted"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsxs)(n.td,{children:["References (",(0,l.jsx)(n.code,{children:"&T"}),")"]}),(0,l.jsx)(n.td,{children:"Pointer"}),(0,l.jsx)(n.td,{children:"Not RC'd (borrowed)"})]})]})]}),"\n",(0,l.jsx)(n.h2,{id:"reference-counting-operations",children:"Reference Counting Operations"}),"\n",(0,l.jsxs)(n.h3,{id:"increment-mux_rc_inc-the-reference-count-when",children:["Increment (",(0,l.jsx)(n.code,{children:"mux_rc_inc the reference count when"}),")"]}),"\n",(0,l.jsx)(n.p,{children:"Increments creating a new reference:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-mux",children:"auto a = some_function()      // Function returns new object\n// ref_count incremented\n\nauto b = a                     // New reference to same object\n// ref_count incremented again\n\npass_to_function(a)           // Passed as argument\n// ref_count incremented\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"When increment happens:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Variable assignment"}),"\n",(0,l.jsx)(n.li,{children:"Function argument passing"}),"\n",(0,l.jsx)(n.li,{children:"Adding to collection"}),"\n",(0,l.jsx)(n.li,{children:"Returning from function"}),"\n"]}),"\n",(0,l.jsxs)(n.h3,{id:"decrement-mux_rc_dec",children:["Decrement (",(0,l.jsx)(n.code,{children:"mux_rc_dec"}),")"]}),"\n",(0,l.jsx)(n.p,{children:"Decrements the reference count when a reference goes out of scope:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-mux",children:"func example() returns void {\n    auto obj = create_object()  // ref_count = 1\n    // ... use obj ...\n}  // obj goes out of scope, ref_count decremented to 0, object freed\n"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"When decrement happens:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Variable assignment (old value)"}),"\n",(0,l.jsx)(n.li,{children:"Function return (local variables)"}),"\n",(0,l.jsx)(n.li,{children:"Scope exit"}),"\n",(0,l.jsx)(n.li,{children:"Collection element removal"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"cleanup",children:"Cleanup"}),"\n",(0,l.jsxs)(n.p,{children:["When ",(0,l.jsx)(n.code,{children:"mux_rc_dec"})," returns ",(0,l.jsx)(n.code,{children:"true"}),", the refcount reached zero and memory is freed:"]}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"For classes with destructors: call destructor"}),"\n",(0,l.jsx)(n.li,{children:"Free the allocation"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"scope-based-tracking",children:"Scope-Based Tracking"}),"\n",(0,l.jsx)(n.p,{children:"The compiler generates cleanup code using a scope stack:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Enter scope"})," \u2192 ",(0,l.jsx)(n.code,{children:"push_rc_scope()"})," (function entry, if-block, loop-body, match-arm)"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Track variable"})," \u2192 ",(0,l.jsx)(n.code,{children:"track_rc_variable(name, alloca)"})," for each RC-allocated variable"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Exit scope"})," \u2192 ",(0,l.jsx)(n.code,{children:"generate_all_scopes_cleanup()"})," iterates through all scopes in reverse order"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"example-scope-cleanup",children:"Example: Scope Cleanup"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-mux",children:"func process() returns void {\n    auto a = create_obj()    // Track: a\n    if condition {\n        auto b = create_obj()  // Track: a, b\n        return  // Cleanup b, then a\n    }\n    // b cleaned up here if condition false\n    auto c = create_obj()    // Track: a, c\n    // Cleanup c, then a\n}\n// Cleanup a\n"})}),"\n",(0,l.jsx)(n.h3,{id:"early-returns",children:"Early Returns"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-mux",children:"func early_return(bool flag) returns void {\n    auto resource = acquire()\n\n    if flag {\n        cleanup(resource)\n        return  // Resource cleaned up before return\n    }\n\n    use(resource)\n    // Resource cleaned up here\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"collections-and-memory",children:"Collections and Memory"}),"\n",(0,l.jsx)(n.p,{children:"Collections contain RC-allocated values. When freed:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Collection's refcount reaches zero"}),"\n",(0,l.jsxs)(n.li,{children:["Collection's container (",(0,l.jsx)(n.code,{children:"Vec<Value>"}),", etc.) is dropped"]}),"\n",(0,l.jsxs)(n.li,{children:["Each contained ",(0,l.jsx)(n.code,{children:"Value"})," has its refcount decremented"]}),"\n",(0,l.jsx)(n.li,{children:"Nested collections are freed recursively"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"nested-collections",children:"Nested Collections"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-mux",children:'auto nested = [\n    {"name": "Alice", "scores": [95, 87, 92]},\n    {"name": "Bob", "scores": [78, 85, 90]}\n]\n'})}),"\n",(0,l.jsx)(n.p,{children:"Cleanup order:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Outer list refcount \u2192 0"}),"\n",(0,l.jsx)(n.li,{children:"Drop outer list"}),"\n",(0,l.jsx)(n.li,{children:"Each map's refcount \u2192 0"}),"\n",(0,l.jsx)(n.li,{children:"Drop each map"}),"\n",(0,l.jsx)(n.li,{children:"Each inner list's refcount \u2192 0"}),"\n",(0,l.jsx)(n.li,{children:"Drop inner lists"}),"\n",(0,l.jsx)(n.li,{children:"All strings freed"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"circular-references",children:"Circular References"}),"\n",(0,l.jsx)(n.p,{children:"Mux does NOT automatically handle circular references:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-mux",children:"class Node {\n    Node next\n}\n\nauto a = Node.new()\nauto b = Node.new()\na.next = b\nb.next = a  // Circular reference!\n"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Memory leak:"})," ",(0,l.jsx)(n.code,{children:"a"})," and ",(0,l.jsx)(n.code,{children:"b"})," will never be freed because each holds a reference to the other."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Solutions:"})}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Use weak references (not currently supported)"}),"\n",(0,l.jsxs)(n.li,{children:["Break cycles manually by setting ",(0,l.jsx)(n.code,{children:"next = None"})," when done"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"value-semantics",children:"Value Semantics"}),"\n",(0,l.jsx)(n.p,{children:"Primitives are passed by value, objects by reference:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-mux",children:"func modify_int(int x) returns void {\n    x = 100  // Only modifies local copy\n}\n\nfunc modify_obj(Circle c) returns void {\n    c.radius = 100  // Modifies the shared object\n}\n"})}),"\n",(0,l.jsx)(n.h3,{id:"reference-vs-value",children:"Reference vs Value"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-mux",children:"auto original = Circle.new(5.0)\nauto copy = original      // Both point to same object\ncopy.radius = 10          // original.radius is also 10!\n\nauto primitive = 42\nauto primitive_copy = primitive\nprimitive_copy = 100      // original is still 42\n"})}),"\n",(0,l.jsxs)(n.h2,{id:"references-t",children:["References (",(0,l.jsx)(n.code,{children:"&T"}),")"]}),"\n",(0,l.jsx)(n.p,{children:"References provide non-owning pointers to values:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-mux",children:"int x = 10\nauto r = &x       // r: &int, points to x\n*r = 20           // x is now 20\n"})}),"\n",(0,l.jsx)(n.h3,{id:"reference-rules",children:"Reference Rules"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"References are non-nullable"}),"\n",(0,l.jsx)(n.li,{children:"No reference arithmetic"}),"\n",(0,l.jsx)(n.li,{children:"References do not affect reference counts"}),"\n",(0,l.jsxs)(n.li,{children:["Optional references: ",(0,l.jsx)(n.code,{children:"Optional<&T>"})]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-mux",children:"func update(&int ref) returns void {\n    *ref = *ref + 1  // Must dereference to read or write\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"memory-safety",children:"Memory Safety"}),"\n",(0,l.jsx)(n.h3,{id:"no-use-after-free",children:"No Use-After-Free"}),"\n",(0,l.jsx)(n.p,{children:"Memory is only freed when all references are gone:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-mux",children:"auto obj = create()\nauto ref = obj\n// ...\nobj = None  // ref still valid\n// ...\nuse(ref)    // Safe: refcount > 0\n"})}),"\n",(0,l.jsx)(n.h3,{id:"no-double-free",children:"No Double-Free"}),"\n",(0,l.jsx)(n.p,{children:"Reference counting prevents double-free:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-mux",children:"auto a = create()\nauto b = a\n// Both point to same allocation\n// Only freed when both a and b go out of scope\n"})}),"\n",(0,l.jsx)(n.h3,{id:"no-memory-leaks-except-cycles",children:"No Memory Leaks (Except Cycles)"}),"\n",(0,l.jsx)(n.p,{children:"Memory is freed when refcount reaches zero, except for:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Circular references"}),"\n",(0,l.jsx)(n.li,{children:"Objects held indefinitely in global scope"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Operation"}),(0,l.jsx)(n.th,{children:"Complexity"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Allocation"}),(0,l.jsx)(n.td,{children:"O(1) amortized"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Clone (increment)"}),(0,l.jsx)(n.td,{children:"O(1) atomic"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Drop (decrement)"}),(0,l.jsx)(n.td,{children:"O(1) atomic"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Clone collection"}),(0,l.jsx)(n.td,{children:"O(n) copy all elements"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"Clone map/set"}),(0,l.jsx)(n.td,{children:"O(n log n) insert all elements"})]})]})]}),"\n",(0,l.jsx)(n.h3,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,l.jsx)(n.p,{children:"Reference count operations use atomic operations:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"// mux_rc_inc\nfn rc_inc(ptr: *mut Value) {\n    let header = get_ref_header(ptr);\n    header.ref_count.fetch_add(1, Ordering::AcqRel);\n}\n\n// mux_rc_dec\nfn rc_dec(ptr: *mut Value) -> bool {\n    let header = get_ref_header(ptr);\n    if header.ref_count.fetch_sub(1, Ordering::AcqRel) == 1 {\n        // Last reference - free memory\n        free(ptr);\n        true\n    } else {\n        false\n    }\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"comparison-to-other-models",children:"Comparison to Other Models"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Model"}),(0,l.jsx)(n.th,{children:"Pros"}),(0,l.jsx)(n.th,{children:"Cons"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"Mux (RC)"})}),(0,l.jsx)(n.td,{children:"Deterministic, simple"}),(0,l.jsx)(n.td,{children:"Cycles leak, overhead"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"Garbage Collection"})}),(0,l.jsx)(n.td,{children:"Handles cycles"}),(0,l.jsx)(n.td,{children:"GC pauses, non-deterministic"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"Manual (C)"})}),(0,l.jsx)(n.td,{children:"Maximum control"}),(0,l.jsx)(n.td,{children:"Use-after-free bugs"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:"Rust (ownership)"})}),(0,l.jsx)(n.td,{children:"Zero-cost, safe"}),(0,l.jsx)(n.td,{children:"Complex borrow checker"})]})]})]}),"\n",(0,l.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/docs/reference/statements",children:"Statements"})," - Statement memory semantics"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/docs/reference/expressions",children:"Expressions"})," - Expression value categories"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/docs/language-guide/classes",children:"Classes"})," - Class memory behavior"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}},8453(e,n,r){r.d(n,{R:()=>i,x:()=>d});var c=r(6540);const l={},s=c.createContext(l);function i(e){const n=c.useContext(s);return c.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),c.createElement(s.Provider,{value:n},e.children)}}}]);