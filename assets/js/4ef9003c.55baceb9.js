"use strict";(globalThis.webpackChunkmux_website=globalThis.webpackChunkmux_website||[]).push([[495],{6443(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"design-notes/philosophy","title":"Design Philosophy","description":"Mux is built on clear principles that guide every design decision. This page explains the \\"why\\" behind Mux\'s design.","source":"@site/docs/design-notes/philosophy.md","sourceDirName":"design-notes","slug":"/design-notes/philosophy","permalink":"/docs/design-notes/philosophy","draft":false,"unlisted":false,"editUrl":"https://github.com/derekcorniello/mux-lang/tree/main/mux-website/docs/design-notes/philosophy.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Modules and Imports","permalink":"/docs/language-guide/modules"},"next":{"title":"Language Comparisons","permalink":"/docs/design-notes/comparisons"}}');var r=i(4848),l=i(8453);const o={},t="Design Philosophy",c={},a=[{value:"Core Principles",id:"core-principles",level:2},{value:"1. Clarity Over Completeness",id:"1-clarity-over-completeness",level:3},{value:"2. Intentional Design Over Feature Accumulation",id:"2-intentional-design-over-feature-accumulation",level:3},{value:"3. Explicit Over Implicit",id:"3-explicit-over-implicit",level:3},{value:"4. Readable Syntax",id:"4-readable-syntax",level:3},{value:"5. Safety Without Complexity",id:"5-safety-without-complexity",level:3},{value:"What Mux Prioritizes",id:"what-mux-prioritizes",level:2},{value:"Focused Design",id:"focused-design",level:3},{value:"Developer Experience Over Raw Performance",id:"developer-experience-over-raw-performance",level:3},{value:"Key Design Decisions",id:"key-design-decisions",level:2},{value:"Why Reference Counting?",id:"why-reference-counting",level:3},{value:"Why No Implicit Conversions?",id:"why-no-implicit-conversions",level:3},{value:"Why No Semicolons?",id:"why-no-semicolons",level:3},{value:"Why Pattern Matching?",id:"why-pattern-matching",level:3},{value:"Why Monomorphization for Generics?",id:"why-monomorphization-for-generics",level:3},{value:"Evolution of Design",id:"evolution-of-design",level:2},{value:"Questions About Design?",id:"questions-about-design",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"design-philosophy",children:"Design Philosophy"})}),"\n",(0,r.jsx)(n.p,{children:'Mux is built on clear principles that guide every design decision. This page explains the "why" behind Mux\'s design.'}),"\n",(0,r.jsx)(n.h2,{id:"core-principles",children:"Core Principles"}),"\n",(0,r.jsx)(n.h3,{id:"1-clarity-over-completeness",children:"1. Clarity Over Completeness"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Principle:"})," It's better to have fewer, well-understood features than many half-baked ones."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What this means in practice:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Mux doesn't try to support every programming paradigm"}),"\n",(0,r.jsx)(n.li,{children:"Features must have clear, explainable semantics"}),"\n",(0,r.jsx)(n.li,{children:"When in doubt, leave it out"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example:"})," Mux doesn't have complex macro systems or compile-time code generation. While powerful, these features make code harder to understand and debug."]}),"\n",(0,r.jsx)(n.h3,{id:"2-intentional-design-over-feature-accumulation",children:"2. Intentional Design Over Feature Accumulation"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Principle:"})," Every feature must justify its complexity by improving understanding or safety."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What this means in practice:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"New features require strong justification"}),"\n",(0,r.jsx)(n.li,{children:"Complexity must provide proportional value"}),"\n",(0,r.jsx)(n.li,{children:'I say "no" more often than "yes"'}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example:"})," Mux uses reference counting instead of a borrow checker. This is intentional, I trade some performance for dramatically simpler mental models."]}),"\n",(0,r.jsx)(n.h3,{id:"3-explicit-over-implicit",children:"3. Explicit Over Implicit"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Principle:"})," Code should be clear about what it's doing. No hidden behavior."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What this means in practice:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No implicit type conversions"}),"\n",(0,r.jsx)(n.li,{children:"No hidden memory allocations (where possible)"}),"\n",(0,r.jsx)(n.li,{children:"Function calls are obvious, not disguised as operators"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",metastring:'title="explicit_conversions.mux"',children:"// ERROR: No implicit conversion\nauto x = 1 + 1.5  \n\n// Explicit: You must choose how to convert\nauto x = (1).to_float() + 1.5  // 2.5 as float\nauto y = 1 + (1.5).to_int()   // 2 as int\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-readable-syntax",children:"4. Readable Syntax"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Principle:"})," Code is read far more than it's written. Optimize for reading."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What this means in practice:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No semicolons (less visual noise)"}),"\n",(0,r.jsxs)(n.li,{children:["Clear keywords (",(0,r.jsx)(n.code,{children:"func"}),", ",(0,r.jsx)(n.code,{children:"returns"}),", ",(0,r.jsx)(n.code,{children:"auto"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"Obvious control flow"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",metastring:'title="readable_syntax.mux"',children:"// Clean and readable\nfunc calculate(int x) returns int {\n    if x > 10 {\n        return x * 2\n    }\n    return x\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"5-safety-without-complexity",children:"5. Safety Without Complexity"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Principle:"})," Memory safety doesn't mean slow performance or difficult code."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What this means in practice:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reference counting for automatic memory management"}),"\n",(0,r.jsxs)(n.li,{children:["No manual ",(0,r.jsx)(n.code,{children:"malloc"}),"/",(0,r.jsx)(n.code,{children:"free"})]}),"\n",(0,r.jsx)(n.li,{children:"No borrow checker to fight with"}),"\n",(0,r.jsx)(n.li,{children:"Compile-time type safety"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff:"})," Reference counting has runtime overhead. That is okay, safety and simplicity are worth it for most use cases."]}),"\n",(0,r.jsx)(n.h2,{id:"what-mux-prioritizes",children:"What Mux Prioritizes"}),"\n",(0,r.jsx)(n.p,{children:"Understanding what Mux focuses on is just as important as what it does not:"}),"\n",(0,r.jsx)(n.h3,{id:"focused-design",children:"Focused Design"}),"\n",(0,r.jsx)(n.p,{children:"Mux has clear opinions about what belongs in the language. It does not try to be everything to everyone."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why:"})," Languages that try to support every paradigm often do nothing particularly well. Focus enables excellence."]}),"\n",(0,r.jsx)(n.h3,{id:"developer-experience-over-raw-performance",children:"Developer Experience Over Raw Performance"}),"\n",(0,r.jsx)(n.p,{children:"Mux prioritizes readability, safety, and developer productivity over absolute maximum performance."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why:"})," Most programs are not CPU-bound. For those that are, profile first, optimize later. Reference counting provides excellent performance for most use cases."]}),"\n",(0,r.jsx)(n.h2,{id:"key-design-decisions",children:"Key Design Decisions"}),"\n",(0,r.jsx)(n.h3,{id:"why-reference-counting",children:"Why Reference Counting?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision:"})," Mux uses reference counting for memory management instead of:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Garbage collection (like Go, Java)"}),"\n",(0,r.jsx)(n.li,{children:"Borrow checking (like Rust)"}),"\n",(0,r.jsx)(n.li,{children:"Manual management (like C)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Rationale:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Simpler than borrow checking"}),"\n",(0,r.jsx)(n.li,{children:"Deterministic cleanup (unlike GC)"}),"\n",(0,r.jsx)(n.li,{children:"No stop-the-world pauses"}),"\n",(0,r.jsx)(n.li,{children:"Cycles require manual breaking (documented pattern)"}),"\n",(0,r.jsx)(n.li,{children:"Slower than Rust in some cases"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"why-no-implicit-conversions",children:"Why No Implicit Conversions?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision:"})," All type conversions must be explicit using ",(0,r.jsx)(n.code,{children:".to_*()"})," methods."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Rationale:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No surprise behavior"}),"\n",(0,r.jsx)(n.li,{children:"Clear what type you're working with"}),"\n",(0,r.jsx)(n.li,{children:"Prevents subtle bugs"}),"\n",(0,r.jsx)(n.li,{children:"More verbose than dynamic languages"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"why-no-semicolons",children:"Why No Semicolons?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision:"})," Statements terminate with newlines, not semicolons."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Rationale:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Less visual clutter"}),"\n",(0,r.jsx)(n.li,{children:"Easier for beginners"}),"\n",(0,r.jsx)(n.li,{children:"Follows Python/Go convention"}),"\n",(0,r.jsx)(n.li,{children:"Requires careful expression design"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"why-pattern-matching",children:"Why Pattern Matching?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision:"})," Include Rust-style pattern matching with guards."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Rationale:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Elegant error handling"}),"\n",(0,r.jsx)(n.li,{children:"Safer than if/else chains"}),"\n",(0,r.jsx)(n.li,{children:"Compiler checks exhaustiveness"}),"\n",(0,r.jsxs)(n.li,{children:["Natural for ",(0,r.jsx)(n.code,{children:"Result"})," and ",(0,r.jsx)(n.code,{children:"Optional"})]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",metastring:'title="pattern_matching_errors.mux"',children:'match divide(10, 0) {\n    Ok(result) { print("Success: " + result.to_string()) }\n    Err(error) { print("Error: " + error) }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"why-monomorphization-for-generics",children:"Why Monomorphization for Generics?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Decision:"})," Generics are specialized at compile-time (like Rust, C++)."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Rationale:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Zero runtime cost"}),"\n",(0,r.jsx)(n.li,{children:"Full type safety"}),"\n",(0,r.jsx)(n.li,{children:"Enables optimization"}),"\n",(0,r.jsx)(n.li,{children:"Increases binary size"}),"\n",(0,r.jsx)(n.li,{children:"Slower compile times"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"evolution-of-design",children:"Evolution of Design"}),"\n",(0,r.jsx)(n.p,{children:"Mux's design will evolve, but guided by these principles:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Changes I might make:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Adding new features that fit the philosophy"}),"\n",(0,r.jsx)(n.li,{children:"Improving syntax based on real-world usage"}),"\n",(0,r.jsx)(n.li,{children:"Better error messages and tooling"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Changes I won't make:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Adding implicit conversions"}),"\n",(0,r.jsx)(n.li,{children:"Introducing a garbage collector"}),"\n",(0,r.jsx)(n.li,{children:"Making the type system optional"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"questions-about-design",children:"Questions About Design?"}),"\n",(0,r.jsxs)(n.p,{children:["The best place to discuss Mux's design decisions is on ",(0,r.jsx)(n.a,{href:"https://github.com/derekcorniello/mux-lang/discussions",children:"GitHub Discussions"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"I value:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Thoughtful critique"}),"\n",(0,r.jsx)(n.li,{children:"Real-world use cases"}),"\n",(0,r.jsx)(n.li,{children:"Honest feedback"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"I don't promise to agree with every suggestion, but I promise to consider them seriously."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Next:"})," ",(0,r.jsx)(n.a,{href:"/docs/design-notes/comparisons",children:"See how Mux compares to other languages"})]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>o,x:()=>t});var s=i(6540);const r={},l=s.createContext(r);function o(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);