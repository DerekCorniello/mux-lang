"use strict";(globalThis.webpackChunkmux_website=globalThis.webpackChunkmux_website||[]).push([[896],{6181(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"language-guide/generics","title":"Generics","description":"Mux supports generics with type parameters and interface bounds, similar to Go and Rust.","source":"@site/docs/language-guide/generics.md","sourceDirName":"language-guide","slug":"/language-guide/generics","permalink":"/docs/language-guide/generics","draft":false,"unlisted":false,"editUrl":"https://github.com/derekcorniello/mux-lang/tree/main/mux-website/docs/language-guide/generics.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Enums / Tagged Unions","permalink":"/docs/language-guide/enums"},"next":{"title":"Collections","permalink":"/docs/language-guide/collections"}}');var t=i(4848),r=i(8453);const l={},c="Generics",a={},d=[{value:"Generic Functions",id:"generic-functions",level:2},{value:"Type Constraints",id:"type-constraints",level:3},{value:"Multiple Type Parameters",id:"multiple-type-parameters",level:3},{value:"Multiple Bounds (AND Semantics)",id:"multiple-bounds-and-semantics",level:3},{value:"Generic Classes",id:"generic-classes",level:2},{value:"Generic Classes with Multiple Type Parameters",id:"generic-classes-with-multiple-type-parameters",level:3},{value:"Built-in Interfaces",id:"built-in-interfaces",level:2},{value:"Operator Mapping",id:"operator-mapping",level:3},{value:"Primitives and Interfaces",id:"primitives-and-interfaces",level:3},{value:"Implementing Interfaces for Custom Types",id:"implementing-interfaces-for-custom-types",level:2},{value:"Generic Functions with Collections",id:"generic-functions-with-collections",level:2},{value:"Monomorphization",id:"monomorphization",level:2},{value:"How Monomorphization Works",id:"how-monomorphization-works",level:3},{value:"Benefits",id:"benefits",level:3},{value:"Tradeoff",id:"tradeoff",level:3},{value:"Type Inference in Generics",id:"type-inference-in-generics",level:2},{value:"Generic Enums",id:"generic-enums",level:2},{value:"Constraints and Bounds",id:"constraints-and-bounds",level:2},{value:"Single Constraint",id:"single-constraint",level:3},{value:"Multiple Constraints (AND)",id:"multiple-constraints-and",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"generics",children:"Generics"})}),"\n",(0,t.jsx)(n.p,{children:"Mux supports generics with type parameters and interface bounds, similar to Go and Rust."}),"\n",(0,t.jsx)(n.h2,{id:"generic-functions",children:"Generic Functions"}),"\n",(0,t.jsx)(n.p,{children:"Functions can be generic over type parameters:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mux",metastring:'title="generic_identity.mux"',children:'// Simple generic function\nfunc identity<T>(T value) returns T {\n    return value\n}\n\n// Usage\nauto a = identity<int>(42)\nauto b = identity<string>("hello")\n'})}),"\n",(0,t.jsx)(n.h3,{id:"type-constraints",children:"Type Constraints"}),"\n",(0,t.jsxs)(n.p,{children:["Use the ",(0,t.jsx)(n.code,{children:"is"})," keyword to constrain type parameters to specific interfaces:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mux",metastring:'title="generic_constraints.mux"',children:'// Generic function with Comparable bound\nfunc max<T is Comparable>(T a, T b) returns T {\n    if a > b {\n        return a\n    }\n    return b\n}\n\n// Generic function with Stringable bound\nfunc greet<T is Stringable>(T value) returns string {\n    return "Hello, " + value.to_string()\n}\n\n// Generic function with Add bound\nfunc add<T is Add>(T a, T b) returns T {\n    return a.add(b)\n}\n\n// Usage\nauto max_int = max<int>(3, 7)           // T = int\nauto max_float = max<float>(3.14, 2.71) // T = float\nauto greeting = greet<string>("World")  // T = string\n'})}),"\n",(0,t.jsx)(n.h3,{id:"multiple-type-parameters",children:"Multiple Type Parameters"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mux",metastring:'title="multiple_type_params.mux"',children:'func pair<T, U>(T first, U second) returns Pair<T, U> {\n    auto p = Pair<T, U>.new()\n    p.first = first\n    p.second = second\n    return p\n}\n\nauto result = pair<int, string>(42, "answer")\n'})}),"\n",(0,t.jsx)(n.h3,{id:"multiple-bounds-and-semantics",children:"Multiple Bounds (AND Semantics)"}),"\n",(0,t.jsx)(n.p,{children:"Type parameters can have multiple constraints:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mux",metastring:'title="multiple_bounds.mux"',children:'// Type must implement BOTH Add AND Stringable\nfunc combine<T is Add & Stringable>(T a, T b) returns string {\n    return (a.add(b)).to_string()\n}\n\n// Only types implementing both interfaces can be used\nauto result = combine<int>(5, 3)  // "8"\n'})}),"\n",(0,t.jsx)(n.h2,{id:"generic-classes",children:"Generic Classes"}),"\n",(0,t.jsx)(n.p,{children:"Classes can be generic over type parameters:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mux",metastring:'title="generic_classes.mux"',children:'class Stack<T> {\n    list<T> items\n    \n    func push(T item) returns void {\n        self.items.push_back(item)\n    }\n    \n    func pop() returns Optional<T> {\n        if self.items.is_empty() {\n            return None.new()\n        }\n        return self.items.pop_back()\n    }\n    \n    func size() returns int {\n        return self.items.size()\n    }\n}\n\n// Usage\nauto int_stack = Stack<int>.new()\nint_stack.push(1)\nint_stack.push(2)\nint_stack.push(3)\n\nauto string_stack = Stack<string>.new()\nstring_stack.push("hello")\nstring_stack.push("world")\n'})}),"\n",(0,t.jsx)(n.h3,{id:"generic-classes-with-multiple-type-parameters",children:"Generic Classes with Multiple Type Parameters"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mux",metastring:'title="generic_pair.mux"',children:'class Pair<T, U> {\n    T first\n    U second\n    \n    func swap() returns Pair<U, T> {\n        auto swapped = Pair<U, T>.new()\n        swapped.first = self.second\n        swapped.second = self.first\n        return swapped\n    }\n    \n    common func from(T a, U b) returns Pair<T, U> {\n        auto pair = Pair<T, U>.new()\n        pair.first = a\n        pair.second = b\n        return pair\n    }\n}\n\n// Usage\nauto pair = Pair<int, string>.from(42, "answer")\nauto reversed = pair.swap()  // Pair<string, int>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"built-in-interfaces",children:"Built-in Interfaces"}),"\n",(0,t.jsx)(n.p,{children:"Mux provides built-in interfaces for common operations:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Interface"}),(0,t.jsx)(n.th,{children:"Methods"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Stringable"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"to_string() -> string"})}),(0,t.jsx)(n.td,{children:"Types that can be converted to string"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Arithmetic"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"add"}),", ",(0,t.jsx)(n.code,{children:"sub"}),", ",(0,t.jsx)(n.code,{children:"mul"}),", ",(0,t.jsx)(n.code,{children:"div"})]}),(0,t.jsx)(n.td,{children:"Types that support all arithmetic operators"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Equatable"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"eq(Self) -> bool"})}),(0,t.jsxs)(n.td,{children:["Types that support ",(0,t.jsx)(n.code,{children:"=="})," and ",(0,t.jsx)(n.code,{children:"!="})," operators"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Comparable"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"cmp(Self) -> int"})}),(0,t.jsxs)(n.td,{children:["Types that support ",(0,t.jsx)(n.code,{children:"<"}),", ",(0,t.jsx)(n.code,{children:"<="}),", ",(0,t.jsx)(n.code,{children:">"}),", ",(0,t.jsx)(n.code,{children:">="})," operators"]})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"operator-mapping",children:"Operator Mapping"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"a + b"})," uses ",(0,t.jsx)(n.code,{children:"Add.add()"})," when type doesn't natively support ",(0,t.jsx)(n.code,{children:"+"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"a > b"})," uses ",(0,t.jsx)(n.code,{children:"Comparable.cmp()"})," returning -1, 0, or 1"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"a == b"})," uses ",(0,t.jsx)(n.code,{children:"Equatable.eq()"})]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"primitives-and-interfaces",children:"Primitives and Interfaces"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Implements"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"Stringable"}),", ",(0,t.jsx)(n.code,{children:"Add"}),", ",(0,t.jsx)(n.code,{children:"Sub"}),", ",(0,t.jsx)(n.code,{children:"Mul"}),", ",(0,t.jsx)(n.code,{children:"Div"}),", ",(0,t.jsx)(n.code,{children:"Arithmetic"}),", ",(0,t.jsx)(n.code,{children:"Equatable"}),", ",(0,t.jsx)(n.code,{children:"Comparable"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"float"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"Stringable"}),", ",(0,t.jsx)(n.code,{children:"Add"}),", ",(0,t.jsx)(n.code,{children:"Sub"}),", ",(0,t.jsx)(n.code,{children:"Mul"}),", ",(0,t.jsx)(n.code,{children:"Div"}),", ",(0,t.jsx)(n.code,{children:"Arithmetic"}),", ",(0,t.jsx)(n.code,{children:"Equatable"}),", ",(0,t.jsx)(n.code,{children:"Comparable"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"string"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"Stringable"}),", ",(0,t.jsx)(n.code,{children:"Add"}),", ",(0,t.jsx)(n.code,{children:"Equatable"}),", ",(0,t.jsx)(n.code,{children:"Comparable"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"bool"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"Stringable"}),", ",(0,t.jsx)(n.code,{children:"Equatable"})]})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"implementing-interfaces-for-custom-types",children:"Implementing Interfaces for Custom Types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mux",metastring:'title="custom_interfaces.mux"',children:"interface Add {\n    func add(Self) returns Self\n}\n\nclass Point {\n    int x\n    int y\n    \n    func add(Point other) returns Point {\n        auto result = Point.new()\n        result.x = self.x + other.x\n        result.y = self.y + other.y\n        return result\n    }\n}\n\n// Now Point can be used with generic functions requiring Add\nfunc sum_points<T is Add>(list<T> points) returns T {\n    auto result = points[0]\n    for i in range(1, points.size()) {\n        result = result.add(points[i])\n    }\n    return result\n}\n\nauto points = [Point.new(), Point.new(), Point.new()]\nauto total = sum_points<Point>(points)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"generic-functions-with-collections",children:"Generic Functions with Collections"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mux",metastring:'title="generic_collections_funcs.mux"',children:"// Generic map function\nfunc map<T, U>(list<T> items, func(T) returns U transform) returns list<U> {\n    auto result = list<U>()\n    for item in items {\n        result.push_back(transform(item))\n    }\n    return result\n}\n\n// Generic filter function\nfunc filter<T>(list<T> items, func(T) returns bool predicate) returns list<T> {\n    auto result = list<T>()\n    for item in items {\n        if predicate(item) {\n            result.push_back(item)\n        }\n    }\n    return result\n}\n\n// Usage\nauto numbers = [1, 2, 3, 4, 5]\nauto doubled = map<int, int>(numbers, func(int n) returns int {\n    return n * 2\n})\n\nauto evens = filter<int>(numbers, func(int n) returns bool {\n    return n % 2 == 0\n})\n"})}),"\n",(0,t.jsx)(n.h2,{id:"monomorphization",children:"Monomorphization"}),"\n",(0,t.jsxs)(n.p,{children:["Mux uses ",(0,t.jsx)(n.strong,{children:"compile-time monomorphization"})," for generics - specialized code is generated for each type instantiation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mux",metastring:'title="monomorphization.mux"',children:'func identity<T>(T value) returns T {\n    return value\n}\n\nauto a = identity<int>(42)        // Generates: identity$$int\nauto b = identity<string>("hello") // Generates: identity$$string\n'})}),"\n",(0,t.jsx)(n.h3,{id:"how-monomorphization-works",children:"How Monomorphization Works"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type inference"}),": Determine concrete types from function arguments"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Name generation"}),": Create unique identifier: ",(0,t.jsx)(n.code,{children:"FunctionName$$Type1$$Type2$$"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type substitution"}),": Replace type parameters with concrete types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Code generation"}),": Emit specialized function body"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Caching"}),": Store generated methods to avoid regeneration"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"benefits",children:"Benefits"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Zero runtime cost"}),": No boxing, no vtables, no type checks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Static dispatch"}),": Methods resolved at compile time"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"LLVM optimization"}),": Each specialization can be fully optimized"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"tradeoff",children:"Tradeoff"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Increased intermediate code size and compilation time"}),": One copy per type combination"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"type-inference-in-generics",children:"Type Inference in Generics"}),"\n",(0,t.jsx)(n.p,{children:"Type parameters can often be inferred from context:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mux",metastring:'title="type_inference_generics.mux"',children:'func identity<T is Stringable>(T value) returns T {\n    return value.to_string()\n}\n\n// Explicit type parameter\nauto a = identity<int>(42)\n\n// Type inferred from argument\nauto b = identity(42)  // T is a int\nauto c = identity("hello")  // T is a string\n'})}),"\n",(0,t.jsx)(n.p,{children:"However, when ambiguous, explicit types are required:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mux",metastring:'title="explicit_generic_types.mux"',children:"// Ambiguous - need explicit types\nlist<int> stack = []\n\n// Clear from context - can use auto\nauto numbers = [1, 2, 3]  // list<int> inferred\n"})}),"\n",(0,t.jsx)(n.h2,{id:"generic-enums",children:"Generic Enums"}),"\n",(0,t.jsx)(n.p,{children:"Enums can be generic:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mux",metastring:'title="generic_enums.mux"',children:'enum Optional<T> {\n    Some(T)\n    None\n}\n\nenum Result<T, E> {\n    Ok(T)\n    Err(E)\n}\n\n// Usage\nauto maybeInt = Some.new(42)              // Optional<int>\nauto success = Ok.new(100)                 // Result<int, E>\nauto failure = Err.new("error message")    // Result<T, string>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{href:"/docs/language-guide/enums",children:"Enums"})," and ",(0,t.jsx)(n.a,{href:"/docs/language-guide/error-handling",children:"Error Handling"})," for more details."]}),"\n",(0,t.jsx)(n.h2,{id:"constraints-and-bounds",children:"Constraints and Bounds"}),"\n",(0,t.jsx)(n.h3,{id:"single-constraint",children:"Single Constraint"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mux",metastring:'title="single_constraint.mux"',children:"func process<T is Stringable>(list<T> items) returns void {\n    for item in items {\n        print(item.to_string())\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"multiple-constraints-and",children:"Multiple Constraints (AND)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mux",metastring:'title="multiple_constraints.mux"',children:"func max<T is Comparable & Stringable>(T a, T b) returns string {\n    if a > b {\n        return a.to_string()\n    }\n    return b.to_string()\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Type ",(0,t.jsx)(n.code,{children:"T"})," must implement ",(0,t.jsx)(n.strong,{children:"all"})," specified interfaces."]}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use type constraints"})," - Specify what operations are needed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prefer interface bounds over concrete types"})," - More flexible"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Leverage monomorphization"})," - No runtime overhead for generics"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use descriptive type parameter names"})," - ",(0,t.jsx)(n.code,{children:"T"}),", ",(0,t.jsx)(n.code,{children:"U"}),", ",(0,t.jsx)(n.code,{children:"K"}),", ",(0,t.jsx)(n.code,{children:"V"})," for simple cases"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Explicit types when ambiguous"})," - Helps readability"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Keep generic functions simple"})," - Complex logic harder to debug"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Document constraints"})," - Make requirements clear"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/language-guide/functions",children:"Functions"})," - Generic functions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/language-guide/classes",children:"Classes"})," - Generic classes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/language-guide/enums",children:"Enums"})," - Generic enums"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/language-guide/error-handling",children:"Error Handling"})," - Optional<T> and Result<T, E>"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453(e,n,i){i.d(n,{R:()=>l,x:()=>c});var s=i(6540);const t={},r=s.createContext(t);function l(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);