"use strict";(globalThis.webpackChunkmux_website=globalThis.webpackChunkmux_website||[]).push([[197],{6571(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"language-guide/variables","title":"Variables and Constants","description":"Mux supports both explicit type declarations and type inference with the auto keyword.","source":"@site/docs/language-guide/variables.md","sourceDirName":"language-guide","slug":"/language-guide/variables","permalink":"/docs/language-guide/variables","draft":false,"unlisted":false,"editUrl":"https://github.com/derekcorniello/mux-lang/tree/main/mux-website/docs/language-guide/variables.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Types","permalink":"/docs/language-guide/types"},"next":{"title":"Operators","permalink":"/docs/language-guide/operators"}}');var s=t(4848),r=t(8453);const a={},l="Variables and Constants",o={},c=[{value:"Variable Declarations",id:"variable-declarations",level:2},{value:"Explicit Typing",id:"explicit-typing",level:3},{value:"Type Inference with <code>auto</code>",id:"type-inference-with-auto",level:3},{value:"Important Rules",id:"important-rules",level:3},{value:"Constants",id:"constants",level:2},{value:"Const Enforcement",id:"const-enforcement",level:3},{value:"When to Use <code>auto</code>",id:"when-to-use-auto",level:2},{value:"Recommended",id:"recommended",level:3},{value:"Explicit Types Recommended",id:"explicit-types-recommended",level:3},{value:"Using Underscore for Unused Values",id:"using-underscore-for-unused-values",level:2},{value:"Variable Scope",id:"variable-scope",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"variables-and-constants",children:"Variables and Constants"})}),"\n",(0,s.jsxs)(n.p,{children:["Mux supports both explicit type declarations and type inference with the ",(0,s.jsx)(n.code,{children:"auto"})," keyword."]}),"\n",(0,s.jsx)(n.h2,{id:"variable-declarations",children:"Variable Declarations"}),"\n",(0,s.jsx)(n.h3,{id:"explicit-typing",children:"Explicit Typing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="variables.mux"',children:'int x = 5\nbool flag = true\nstring name = "MuxLang"\nfloat pi = 3.14159\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"type-inference-with-auto",children:["Type Inference with ",(0,s.jsx)(n.code,{children:"auto"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="type_inference.mux"',children:'// Type inferred from initializer\nauto x = 42          // inferred as int\nauto pi = 3.14159    // inferred as float\nauto name = "Mux"    // inferred as string\n\n// Explicit type annotation when needed\nlist<string> names = []\nmap<string, int> scores = {"Alice": 90, "Bob": 85}\n\n// Valid inference\nauto value = someFunction()\nauto numbers = [1, 2, 3]\n'})}),"\n",(0,s.jsx)(n.h3,{id:"important-rules",children:"Important Rules"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="variable_rules.mux"',children:"// Invalid - no initializer with 'auto'\n// auto x  // ERROR: cannot infer type without initializer\n\n// Function parameters must be explicitly typed\n// func process(auto item) returns void { }  // ERROR\nfunc process(int item) returns void { }   // Valid\n\n// Unused parameter\nfunc process(int item, int _) returns void { }  // second parameter unused\n"})}),"\n",(0,s.jsxs)(n.p,{children:["All declarations require either an explicit type or ",(0,s.jsx)(n.code,{children:"auto"})," with an initializer. Semicolons are not used."]}),"\n",(0,s.jsx)(n.h2,{id:"constants",children:"Constants"}),"\n",(0,s.jsx)(n.p,{children:"Constants are immutable values that cannot be reassigned or modified after initialization:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="constants.mux"',children:"// Top-level constants\nconst int MAX = 100\nconst float PI = 3.14159\n\n// Function-level constants\nfunc calculate() returns int {\n    const int MULTIPLIER = 10\n    const float TAX_RATE = 0.08\n    int value = 100\n    return value * MULTIPLIER\n}\n\n// Constants in classes\nclass Config {\n    const int MAX_RETRIES\n    int current_retry\n    \n    func increment() returns void {\n        self.current_retry++  // OK - mutable field\n        // self.MAX_RETRIES++  // ERROR: Cannot modify const field\n    }\n}\n\nauto cfg = Config.new()\ncfg.current_retry = 1  // OK - mutable field\n// cfg.MAX_RETRIES = 5  // ERROR: Cannot assign to const field\n"})}),"\n",(0,s.jsx)(n.h3,{id:"const-enforcement",children:"Const Enforcement"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Cannot reassign: ",(0,s.jsx)(n.code,{children:"const_var = new_value"})," \u2192 ERROR"]}),"\n",(0,s.jsxs)(n.li,{children:["Cannot use compound assignment: ",(0,s.jsx)(n.code,{children:"const_var += 1"})," \u2192 ERROR"]}),"\n",(0,s.jsxs)(n.li,{children:["Cannot increment/decrement: ",(0,s.jsx)(n.code,{children:"const_var++"})," or ",(0,s.jsx)(n.code,{children:"const_var--"})," \u2192 ERROR"]}),"\n",(0,s.jsx)(n.li,{children:"Applies to both identifiers and class fields"}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"const"})," when you want a value that won't change after initialization"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"when-to-use-auto",children:["When to Use ",(0,s.jsx)(n.code,{children:"auto"})]}),"\n",(0,s.jsx)(n.h3,{id:"recommended",children:"Recommended"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Local variables with obvious initialization"}),"\n",(0,s.jsx)(n.li,{children:"Complex generic types that are clear from context"}),"\n",(0,s.jsx)(n.li,{children:"Temporary variables in calculations"}),"\n",(0,s.jsx)(n.li,{children:"Iterator variables in loops"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"explicit-types-recommended",children:"Explicit Types Recommended"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="explicit_types.mux"',children:"// Empty collections need explicit types\nlist<int> empty = []           // explicit type needed\nauto empty = list<int>()       // or explicit constructor\n\n// Uninitialized variables\nResult<int, string> pending    // explicit type needed\n\n// Function parameters (required)\nfunc process(int data) returns void { }\n\n// Generic instantiation when ambiguous\nStack<int> stack = Stack<int>.new()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"using-underscore-for-unused-values",children:"Using Underscore for Unused Values"}),"\n",(0,s.jsxs)(n.p,{children:["The underscore ",(0,s.jsx)(n.code,{children:"_"})," is a placeholder for values you don't need:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="underscore.mux"',children:'// Unused function parameters\nfunc process(int data, string _) returns void { }\n\n// Unused loop counters\nfor int _ in range(0, 10) { // still need a type annotation\n    doSomething()\n}\n\n// Unused pattern match values\nmatch result {\n    Ok(_) { print("Success") }  // don\'t care about the value\n    Err(_) { print("Error") }   // don\'t care about the error details\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Best Practice:"})," Use ",(0,s.jsx)(n.code,{children:"_"})," when a value is required by syntax but not needed in your code. Don't overuse it when descriptive names would improve readability."]}),"\n",(0,s.jsx)(n.h2,{id:"variable-scope",children:"Variable Scope"}),"\n",(0,s.jsx)(n.p,{children:"Variables are scoped to the block in which they are declared:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="scope.mux"',children:"func example() returns void {\n    auto x = 10  // Scoped to function\n    \n    if x > 5 {\n        auto y = 20  // Scoped to if block\n        print(y.to_string())\n    }\n    \n    // print(y.to_string())  // ERROR: y is out of scope\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Unless you create a closure, then you can capture variables from the enclosing scope:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="closure_scope.mux"',children:"func makeCounter() returns func() returns int {\n    auto count = 0  // Captured variable\n    return func() returns int {\n        count++  // Modifies captured variable\n        print(count.to_string())\n        return count\n    }\n}\nauto counter = makeCounter()\ncounter()  // prints 1\ncounter()  // prints 2\n"})}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/language-guide/types",children:"Types"})," - Type system and conversions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/language-guide/functions",children:"Functions"})," - Function declarations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/language-guide/classes",children:"Classes"})," - Class fields and constants"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>a,x:()=>l});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);