"use strict";(globalThis.webpackChunkmux_website=globalThis.webpackChunkmux_website||[]).push([[879],{8186(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"design-notes/comparisons","title":"Language Comparisons","description":"This page shows how Mux approaches common programming tasks compared to Rust, Go, Python, and TypeScript. The goal is clarity, not criticism, each language makes different tradeoffs.","source":"@site/docs/design-notes/comparisons.md","sourceDirName":"design-notes","slug":"/design-notes/comparisons","permalink":"/docs/design-notes/comparisons","draft":false,"unlisted":false,"editUrl":"https://github.com/derekcorniello/mux-lang/tree/main/mux-website/docs/design-notes/comparisons.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Design Philosophy","permalink":"/docs/design-notes/philosophy"},"next":{"title":"Language Reference","permalink":"/docs/reference/"}}');var r=t(4848),s=t(8453);const l={},o="Language Comparisons",c={},a=[{value:"Type Conversions",id:"type-conversions",level:2},{value:"Mux: Explicit Only",id:"mux-explicit-only",level:3},{value:"Python: Implicit",id:"python-implicit",level:3},{value:"Rust: Explicit",id:"rust-explicit",level:3},{value:"Go: Explicit",id:"go-explicit",level:3},{value:"TypeScript: Compile-Time Types Only",id:"typescript-compile-time-types-only",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Mux: Result Type",id:"mux-result-type",level:3},{value:"Rust: Result Type",id:"rust-result-type",level:3},{value:"Go: Explicit Error Returns",id:"go-explicit-error-returns",level:3},{value:"Python: Exceptions",id:"python-exceptions",level:3},{value:"TypeScript: Exceptions (Runtime Types Only)",id:"typescript-exceptions-runtime-types-only",level:3},{value:"Memory Management",id:"memory-management",level:2},{value:"Mux: Reference Counting",id:"mux-reference-counting",level:3},{value:"Rust: Ownership + Borrow Checker",id:"rust-ownership--borrow-checker",level:3},{value:"Go: Garbage Collection",id:"go-garbage-collection",level:3},{value:"Python: Reference Counting + GC",id:"python-reference-counting--gc",level:3},{value:"TypeScript: Garbage Collection (V8/Node.js)",id:"typescript-garbage-collection-v8nodejs",level:3},{value:"Generics",id:"generics",level:2},{value:"Mux: Monomorphization",id:"mux-monomorphization",level:3},{value:"Rust: Monomorphization",id:"rust-monomorphization",level:3},{value:"Go: Generics (Recent)",id:"go-generics-recent",level:3},{value:"Python: Duck Typing",id:"python-duck-typing",level:3},{value:"TypeScript: Type Erasure (No Runtime Types)",id:"typescript-type-erasure-no-runtime-types",level:3},{value:"Pattern Matching",id:"pattern-matching",level:2},{value:"Mux: Match with Guards",id:"mux-match-with-guards",level:3},{value:"Rust: Match",id:"rust-match",level:3},{value:"Go: Switch",id:"go-switch",level:3},{value:"Python: Match (3.10+)",id:"python-match-310",level:3},{value:"TypeScript: No Runtime Pattern Matching",id:"typescript-no-runtime-pattern-matching",level:3},{value:"Summary Table",id:"summary-table",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"language-comparisons",children:"Language Comparisons"})}),"\n",(0,r.jsx)(n.p,{children:"This page shows how Mux approaches common programming tasks compared to Rust, Go, Python, and TypeScript. The goal is clarity, not criticism, each language makes different tradeoffs."}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Why TypeScript?"}),' TypeScript is included to show the difference between "static types that exist only at compile time" versus "static types that exist at runtime." Many developers know TypeScript as their "typed language," so seeing what you lose without runtime type information helps explain Mux\'s design decisions.']}),"\n",(0,r.jsx)(n.h2,{id:"type-conversions",children:"Type Conversions"}),"\n",(0,r.jsx)(n.h3,{id:"mux-explicit-only",children:"Mux: Explicit Only"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",metastring:'title="mux_explicit.mux"',children:"auto x = 42\nauto y = 3.14\n\n// ERROR: No implicit conversion\n// auto sum = x + y\n\n// Must be explicit\nauto sum = x.to_float() + y  // 45.14\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Philosophy:"})," No surprises. You always know what type you're working with."]}),"\n",(0,r.jsx)(n.h3,{id:"python-implicit",children:"Python: Implicit"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",metastring:'title="python_implicit.py"',children:"x = 42\ny = 3.14\nsum = x + y  # 45.14 (int becomes float automatically)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff:"})," Convenient but can lead to unexpected behavior with complex types."]}),"\n",(0,r.jsx)(n.h3,{id:"rust-explicit",children:"Rust: Explicit"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="rust_explicit.rs"',children:"let x: i32 = 42;\nlet y: f64 = 3.14;\n// let sum = x + y;  // ERROR\n\nlet sum = (x as f64) + y;  // 45.14\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Similarity:"})," Like Mux, Rust requires explicit conversions for safety."]}),"\n",(0,r.jsx)(n.h3,{id:"go-explicit",children:"Go: Explicit"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="go_explicit.go"',children:"x := 42\ny := 3.14\n// sum := x + y  // ERROR\n\nsum := float64(x) + y  // 45.14\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Similarity:"})," Go also requires explicit conversions, using C-style casts."]}),"\n",(0,r.jsx)(n.h3,{id:"typescript-compile-time-types-only",children:"TypeScript: Compile-Time Types Only"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'title="typescript_types.ts"',children:"let x: number = 42;\nlet y: number = 3.14;\nlet sum = x + y;  // 45.14 (both are 'number' type)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff:"})," TypeScript's unified ",(0,r.jsx)(n.code,{children:"number"})," type is convenient but can hide precision issues. Type information is erased at runtime, no generics, pattern matching, or type-safe enums exist at runtime."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.h3,{id:"mux-result-type",children:"Mux: Result Type"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",metastring:'title="mux_result.mux"',children:'func divide(int a, int b) returns Result<int, string> {\n    if b == 0 {\n        return Err("division by zero")\n    }\n    return Ok(a / b)\n}\n\nmatch divide(10, 2) {\n    Ok(result) { print(result.to_string()) }\n    Err(error) { print("Error: " + error) }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Philosophy:"})," Errors are values. Compiler enforces handling."]}),"\n",(0,r.jsx)(n.h3,{id:"rust-result-type",children:"Rust: Result Type"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="rust_result.rs"',children:'fn divide(a: i32, b: i32) -> Result<i32, String> {\n    if b == 0 {\n        return Err("division by zero".to_string());\n    }\n    Ok(a / b)\n}\n\nmatch divide(10, 2) {\n    Ok(result) => println!("{}", result),\n    Err(error) => println!("Error: {}", error),\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Similarity:"})," Nearly identical approach. Mux was directly inspired by Rust here."]}),"\n",(0,r.jsx)(n.h3,{id:"go-explicit-error-returns",children:"Go: Explicit Error Returns"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="go_errors.go"',children:'func divide(a, b int) (int, error) {\n    if b == 0 {\n        return 0, errors.New("division by zero")\n    }\n    return a / b, nil\n}\n\nresult, err := divide(10, 2)\nif err != nil {\n    fmt.Println("Error:", err)\n} else {\n    fmt.Println(result)\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff:"})," More verbose, easier to accidentally ignore errors."]}),"\n",(0,r.jsx)(n.h3,{id:"python-exceptions",children:"Python: Exceptions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",metastring:'title="python_exceptions.py"',children:'def divide(a, b):\n    if b == 0:\n        raise ValueError("division by zero")\n    return a / b\n\ntry:\n    result = divide(10, 2)\n    print(result)\nexcept ValueError as e:\n    print(f"Error: {e}")\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff:"})," Can forget to handle exceptions. No compile-time checking."]}),"\n",(0,r.jsx)(n.h3,{id:"typescript-exceptions-runtime-types-only",children:"TypeScript: Exceptions (Runtime Types Only)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'title="typescript_exceptions.ts"',children:'function divide(a: number, b: number): number {\n    if (b === 0) {\n        throw new Error("division by zero");\n    }\n    return a / b;\n}\n\ntry {\n    const result = divide(10, 2);\n    console.log(result);\n} catch (e) {\n    console.log("Error:", e);\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff:"})," Similar to Python. No compile-time enforcement. TypeScript types are erased at runtime, the compiler cannot help you catch missing error handling."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"memory-management",children:"Memory Management"}),"\n",(0,r.jsx)(n.h3,{id:"mux-reference-counting",children:"Mux: Reference Counting"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",metastring:'title="mux_memory.mux"',children:"auto data = [1, 2, 3, 4, 5]\n// Reference count = 1\n\nauto data2 = data\n// Reference count = 2\n\n// When data and data2 go out of scope,\n// memory is automatically freed\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Philosophy:"})," Simple and automatic. Reference counting provides memory safety without a borrow checker."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff:"})," Reference counting has some runtime overhead. Mux avoids creating reference cycles through careful API design."]}),"\n",(0,r.jsx)(n.h3,{id:"rust-ownership--borrow-checker",children:"Rust: Ownership + Borrow Checker"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="rust_memory.rs"',children:"let data = vec![1, 2, 3, 4, 5];\n// Owned by 'data'\n\nlet data2 = &data;  // Borrowed\n// Both can exist, but data2 is read-only\n\n// When data goes out of scope, memory is freed\n// No runtime overhead\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff:"})," Zero runtime cost comes with a steeper learning curve. Rust's borrow checker is a powerful tool but requires significant investment to master."]}),"\n",(0,r.jsx)(n.h3,{id:"go-garbage-collection",children:"Go: Garbage Collection"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="go_memory.go"',children:"data := []int{1, 2, 3, 4, 5}\n// Managed by GC\n\ndata2 := data\n// Both reference same memory\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff:"})," Easy to use, but GC pauses can be unpredictable."]}),"\n",(0,r.jsx)(n.h3,{id:"python-reference-counting--gc",children:"Python: Reference Counting + GC"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",metastring:'title="python_memory.py"',children:"data = [1, 2, 3, 4, 5]\n# Reference counted\n\ndata2 = data\n# Reference count increases\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Similarity:"})," Like Mux, but Python also has a cycle-detecting GC."]}),"\n",(0,r.jsx)(n.h3,{id:"typescript-garbage-collection-v8nodejs",children:"TypeScript: Garbage Collection (V8/Node.js)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'title="typescript_memory.ts"',children:"let data = [1, 2, 3, 4, 5];\n// Managed by V8's GC, no compile-time guarantees\n\nlet data2 = data;\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff:"})," Very easy to use, but GC behavior varies by runtime and there's no compile-time memory safety."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"generics",children:"Generics"}),"\n",(0,r.jsx)(n.h3,{id:"mux-monomorphization",children:"Mux: Monomorphization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",metastring:'title="mux_generics.mux"',children:'func identity<T>(T value) returns T {\n    return value\n}\n\nauto x = identity(42)        // Generates identity$$int\nauto y = identity("hello")   // Generates identity$$string\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Philosophy:"})," Zero runtime cost. Specialized code for each type."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff:"})," Larger binary size, slower compilation."]}),"\n",(0,r.jsx)(n.h3,{id:"rust-monomorphization",children:"Rust: Monomorphization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="rust_generics.rs"',children:'fn identity<T>(value: T) -> T {\n    value\n}\n\nlet x = identity(42);        // Monomorphized to i32\nlet y = identity("hello");   // Monomorphized to &str\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Similarity:"})," Exact same approach as Mux."]}),"\n",(0,r.jsx)(n.h3,{id:"go-generics-recent",children:"Go: Generics (Recent)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="go_generics.go"',children:'func identity[T any](value T) T {\n    return value\n}\n\nx := identity(42)\ny := identity("hello")\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note:"})," Go added generics in 1.18. Implementation may use monomorphization or runtime dispatch depending on the case."]}),"\n",(0,r.jsx)(n.h3,{id:"python-duck-typing",children:"Python: Duck Typing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",metastring:'title="python_duck_typing.py"',children:'def identity(value):\n    return value\n\nx = identity(42)\ny = identity("hello")\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff:"})," No compile-time checking. Errors happen at runtime."]}),"\n",(0,r.jsx)(n.h3,{id:"typescript-type-erasure-no-runtime-types",children:"TypeScript: Type Erasure (No Runtime Types)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'title="typescript_generics.ts"',children:'function identity<T>(value: T): T {\n    return value;\n}\n\nlet x = identity(42);\nlet y = identity("hello");\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff:"})," Generics exist only at compile time. At runtime, both are just ",(0,r.jsx)(n.code,{children:"any"})," type, there is no type information to enable pattern matching or type-safe operations."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"pattern-matching",children:"Pattern Matching"}),"\n",(0,r.jsx)(n.h3,{id:"mux-match-with-guards",children:"Mux: Match with Guards"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",metastring:'title="mux_pattern_matching.mux"',children:'match value {\n    Some(x) if x > 10 { print("Large: " + x.to_string()) }\n    Some(x) { print("Small: " + x.to_string()) }\n    None { print("No value") }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Philosophy:"})," Exhaustive, compiler-checked, guards for complex conditions."]}),"\n",(0,r.jsx)(n.h3,{id:"rust-match",children:"Rust: Match"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:'title="rust_pattern_matching.rs"',children:'match value {\n    Some(x) if x > 10 => println!("Large: {}", x),\n    Some(x) => println!("Small: {}", x),\n    None => println!("No value"),\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Similarity:"})," Nearly identical to Mux."]}),"\n",(0,r.jsx)(n.h3,{id:"go-switch",children:"Go: Switch"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",metastring:'title="go_switch.go"',children:'switch {\ncase value != nil && *value > 10:\n    fmt.Println("Large:", *value)\ncase value != nil:\n    fmt.Println("Small:", *value)\ndefault:\n    fmt.Println("No value")\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff:"})," More verbose, no exhaustiveness checking."]}),"\n",(0,r.jsx)(n.h3,{id:"python-match-310",children:"Python: Match (3.10+)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",metastring:'title="python_pattern_matching.py"',children:'match value:\n    case x if x > 10:\n        print(f"Large: {x}")\n    case x:\n        print(f"Small: {x}")\n    case None:\n        print("No value")\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Similarity:"})," Similar structure, but Python's match is runtime-only."]}),"\n",(0,r.jsx)(n.h3,{id:"typescript-no-runtime-pattern-matching",children:"TypeScript: No Runtime Pattern Matching"}),"\n",(0,r.jsx)(n.p,{children:"TypeScript doesn't have pattern matching. You'd use if/else or switch:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'title="typescript_conditionals.ts"',children:'if (value !== null && value > 10) {\n    console.log(`Large: ${value}`);\n} else if (value !== null) {\n    console.log(`Small: ${value}`);\n} else {\n    console.log("No value");\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff:"})," Without runtime type information, exhaustiveness checking is impossible. You can't know at runtime if you've covered all cases."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"summary-table",children:"Summary Table"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Feature"}),(0,r.jsx)(n.th,{children:"Mux"}),(0,r.jsx)(n.th,{children:"Rust"}),(0,r.jsx)(n.th,{children:"Go"}),(0,r.jsx)(n.th,{children:"Python"}),(0,r.jsx)(n.th,{children:"TypeScript"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Type Safety"})}),(0,r.jsx)(n.td,{children:"Strong, static"}),(0,r.jsx)(n.td,{children:"Strong, static"}),(0,r.jsx)(n.td,{children:"Strong, static"}),(0,r.jsx)(n.td,{children:"Dynamic"}),(0,r.jsx)(n.td,{children:"Static (compile-time only)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Type Conversions"})}),(0,r.jsx)(n.td,{children:"Explicit"}),(0,r.jsx)(n.td,{children:"Explicit"}),(0,r.jsx)(n.td,{children:"Explicit"}),(0,r.jsx)(n.td,{children:"Implicit"}),(0,r.jsx)(n.td,{children:"Explicit (erased at runtime)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Error Handling"})}),(0,r.jsx)(n.td,{children:"Result type"}),(0,r.jsx)(n.td,{children:"Result type"}),(0,r.jsx)(n.td,{children:"Error values"}),(0,r.jsx)(n.td,{children:"Exceptions"}),(0,r.jsx)(n.td,{children:"Exceptions (no compile-time checks)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Memory Management"})}),(0,r.jsx)(n.td,{children:"Reference counting"}),(0,r.jsx)(n.td,{children:"Ownership"}),(0,r.jsx)(n.td,{children:"GC"}),(0,r.jsx)(n.td,{children:"Ref count + GC"}),(0,r.jsx)(n.td,{children:"GC (no compile-time safety)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Generics"})}),(0,r.jsx)(n.td,{children:"Monomorphization"}),(0,r.jsx)(n.td,{children:"Monomorphization"}),(0,r.jsx)(n.td,{children:"Monomorphization/dispatch"}),(0,r.jsx)(n.td,{children:"Duck typing"}),(0,r.jsx)(n.td,{children:"Type erasure (no runtime types)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Pattern Matching"})}),(0,r.jsx)(n.td,{children:"Yes, with guards"}),(0,r.jsx)(n.td,{children:"Yes, with guards"}),(0,r.jsx)(n.td,{children:"Switch only"}),(0,r.jsx)(n.td,{children:"Yes (3.10+)"}),(0,r.jsx)(n.td,{children:"No (no runtime types)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Learning Curve"})}),(0,r.jsx)(n.td,{children:"Low-Medium"}),(0,r.jsx)(n.td,{children:"High"}),(0,r.jsx)(n.td,{children:"Low"}),(0,r.jsx)(n.td,{children:"Low"}),(0,r.jsx)(n.td,{children:"Low-Medium"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Performance"})}),(0,r.jsx)(n.td,{children:"Medium-High"}),(0,r.jsx)(n.td,{children:"Highest"}),(0,r.jsx)(n.td,{children:"High"}),(0,r.jsx)(n.td,{children:"Low"}),(0,r.jsx)(n.td,{children:"Medium (runtime dependent)"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Next:"})," Learn about ",(0,r.jsx)(n.a,{href:"/docs/design-notes/philosophy",children:"Mux's design philosophy"})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>l,x:()=>o});var i=t(6540);const r={},s=i.createContext(r);function l(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);