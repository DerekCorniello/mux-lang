"use strict";(globalThis.webpackChunkmux_website=globalThis.webpackChunkmux_website||[]).push([[367],{2082(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"language-guide/types","title":"Types","description":"Mux uses strict static typing with NO implicit type conversions. All type conversions must be explicit using conversion methods.","source":"@site/docs/language-guide/types.md","sourceDirName":"language-guide","slug":"/language-guide/types","permalink":"/docs/language-guide/types","draft":false,"unlisted":false,"editUrl":"https://github.com/derekcorniello/mux-lang/tree/main/mux-website/docs/language-guide/types.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Overview","permalink":"/docs/language-guide/overview"},"next":{"title":"Variables and Constants","permalink":"/docs/language-guide/variables"}}');var r=t(4848),i=t(8453);const l={},o="Types",d={},c=[{value:"Primitive Types",id:"primitive-types",level:2},{value:"Type Conversions",id:"type-conversions",level:2},{value:"Numeric Conversions",id:"numeric-conversions",level:3},{value:"String Parsing (Fallible Conversions)",id:"string-parsing-fallible-conversions",level:3},{value:"No Implicit Conversions",id:"no-implicit-conversions",level:3},{value:"Conversion Methods Reference",id:"conversion-methods-reference",level:2},{value:"Composite Types",id:"composite-types",level:2},{value:"Tuples",id:"tuples",level:2},{value:"References",id:"references",level:2},{value:"See Also",id:"see-also",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"types",children:"Types"})}),"\n",(0,r.jsxs)(n.p,{children:["Mux uses ",(0,r.jsx)(n.strong,{children:"strict static typing"})," with ",(0,r.jsx)(n.strong,{children:"NO implicit type conversions"}),". All type conversions must be explicit using conversion methods."]}),"\n",(0,r.jsx)(n.h2,{id:"primitive-types",children:"Primitive Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",metastring:'title="primitive_types.mux"',children:"int      // 64-bit signed integer\nfloat    // 64-bit IEEE-754\nbool     // true | false\nchar     // Unicode code point\nstring   // UTF-8 sequence\n"})}),"\n",(0,r.jsx)(n.h2,{id:"type-conversions",children:"Type Conversions"}),"\n",(0,r.jsx)(n.h3,{id:"numeric-conversions",children:"Numeric Conversions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",metastring:'title="numeric_conversions.mux"',children:'// Integer conversions\nauto x = 42\nauto x_float = x.to_float()     // int -> float\nauto x_str = x.to_string()      // int -> string\nauto x_same = x.to_int()        // int -> int (identity)\n\n// Float conversions\nauto pi = 3.14\nauto pi_int = pi.to_int()       // float -> int (truncates: 3)\nauto pi_str = pi.to_string()    // float -> string\nauto pi_same = pi.to_float()    // float -> float (identity)\n\n// Boolean conversions\nauto flag = true\nauto flag_int = flag.to_int()   // bool -> int (true=1, false=0)\nauto flag_float = flag.to_float() // bool -> float (true=1.0, false=0.0)\nauto flag_str = flag.to_string() // bool -> string ("true" or "false")\n\n// Char conversions\nauto ch = \'A\'\nauto ch_str = ch.to_string()    // char -> string\n\n// Method calls on literals require parentheses\nauto num = (3).to_string()      // Valid\nauto val = (42).to_float()      // Valid\n// auto bad = 3.to_string()     // ERROR: parsed as float 3.0\n'})}),"\n",(0,r.jsx)(n.h3,{id:"string-parsing-fallible-conversions",children:"String Parsing (Fallible Conversions)"}),"\n",(0,r.jsxs)(n.p,{children:["String and char parsing methods return ",(0,r.jsx)(n.code,{children:"Result<T, string>"})," because they can fail:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",metastring:'title="string_parsing.mux"',children:'// String to number (returns Result)\nauto num_str = "42"\nauto result = num_str.to_int()\nmatch result {\n    Ok(value) {\n        print("Parsed: " + value.to_string())  // "Parsed: 42"\n    }\n    Err(error) {\n        print("Parse error: " + error)\n    }\n}\n\n// String to float\nauto float_str = "3.14159"\nauto float_result = float_str.to_float()\nmatch float_result {\n    Ok(value) { print(value.to_string()) }\n    Err(msg) { print("Error: " + msg) }\n}\n\n// Char to digit (only works for \'0\'-\'9\')\nauto digit_char = \'5\'\nauto digit_result = digit_char.to_int()\nmatch digit_result {\n    Ok(digit) { print(digit.to_string()) }  // "5"\n    Err(msg) { print(msg) }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"no-implicit-conversions",children:"No Implicit Conversions"}),"\n",(0,r.jsxs)(n.p,{children:["The following operations are ",(0,r.jsx)(n.strong,{children:"compile-time errors"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",metastring:'title="implicit_conversions.mux"',children:'// Type mismatches in binary operations\nauto bad1 = 1 + 1.0        // ERROR: cannot add int and float\nauto bad2 = "hello" + 3    // ERROR: cannot add string and int\nauto bad3 = true + false   // ERROR: cannot add bool and bool\n\n// Type mismatches in comparisons\nauto bad4 = 1 < 1.0        // ERROR: cannot compare int and float\nauto bad5 = "a" == 1       // ERROR: cannot compare string and int\n\n// Correct usage requires explicit conversion\nauto good1 = 1 + (1.0).to_int()           // OK: 2\nauto good2 = "hello" + (3).to_string()    // OK: "hello3"\nauto good3 = 1.to_float() < 1.0           // OK: true\n'})}),"\n",(0,r.jsx)(n.h2,{id:"conversion-methods-reference",children:"Conversion Methods Reference"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"From Type"}),(0,r.jsx)(n.th,{children:"Method"}),(0,r.jsx)(n.th,{children:"Returns"}),(0,r.jsx)(n.th,{children:"Notes"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_string()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:"Converts to string representation"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_float()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})}),(0,r.jsx)(n.td,{children:"Converts to floating-point"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_int()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})}),(0,r.jsx)(n.td,{children:"Identity function"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_string()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:"Converts to string representation"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_int()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})}),(0,r.jsx)(n.td,{children:"Truncates decimal part"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_float()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})}),(0,r.jsx)(n.td,{children:"Identity function"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_string()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:'Returns "true" or "false"'})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_int()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})}),(0,r.jsx)(n.td,{children:"Returns 1 or 0"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_float()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})}),(0,r.jsx)(n.td,{children:"Returns 1.0 or 0.0"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"char"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_string()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:"Converts char to string"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"char"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_int()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Result<int, string>"})}),(0,r.jsx)(n.td,{children:"Digit value for '0'-'9' only"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_string()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:"Identity function"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_int()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Result<int, string>"})}),(0,r.jsx)(n.td,{children:"Parses string as integer"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_float()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Result<float, string>"})}),(0,r.jsx)(n.td,{children:"Parses string as float"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"composite-types",children:"Composite Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",metastring:'title="composite_types.mux"',children:"Optional<T>        // Represents a value that may or may not exist\nResult<T, E>       // Represents success (T) or error (E)\nlist<T>            // Ordered collection\nmap<K, V>          // Key-value pairs\nset<T>             // Unique elements\ntuple<T, U>        // Fixed size pair\n"})}),"\n",(0,r.jsx)(n.h2,{id:"tuples",children:"Tuples"}),"\n",(0,r.jsx)(n.p,{children:"Tuples are fixed size pairs. A tuple always has exactly two elements."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",metastring:'title="tuple_basics.mux"',children:'auto pair = (1, "one")\ntuple<int, string> typed = (2, "two")\n\nprint(pair.left.to_string())   // "1"\nprint(pair.right.to_string())  // "one"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Tuples also support ",(0,r.jsx)(n.code,{children:"to_string()"})," and a default constructor:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",metastring:'title="tuple_default.mux"',children:'auto empty = tuple<int, string>.new()  // (0, "")\n'})}),"\n",(0,r.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,r.jsx)(n.p,{children:"Mux supports references for safe memory access:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",metastring:'title="references.mux"',children:'// Basic reference usage\nint x = 10\nauto r = &x      // r is of type &int\nprint("ref value: " + (*r).to_string())  // 10 - explicit dereference with *\n\n*r = 20          // Changes x to 20 via dereference\nprint("x is now: " + x.to_string())  // 20\n\n// References to list elements\nauto numbers = [1, 2, 3, 4, 5]\nauto first = &numbers[0]  // &int\nprint("first element: " + (*first).to_string())  // 1\n\n// Function taking a reference\nfunc update(&int ref) returns void {\n    *ref = *ref + 1  // Must explicitly dereference to modify\n}\n\nupdate(&x)\nprint("val after update: " + x.to_string())  // 21\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Reference Syntax:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Create reference: ",(0,r.jsx)(n.code,{children:"&variable"})," or ",(0,r.jsx)(n.code,{children:"&expression"})]}),"\n",(0,r.jsxs)(n.li,{children:["Dereference: ",(0,r.jsx)(n.code,{children:"*reference"})," (required for both reading and writing)"]}),"\n",(0,r.jsxs)(n.li,{children:["Pass to functions: ",(0,r.jsx)(n.code,{children:"func(&int ref)"})," declares parameter, ",(0,r.jsx)(n.code,{children:"update(&x)"})," passes reference"]}),"\n",(0,r.jsx)(n.li,{children:"References to references: Not supported"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/language-guide/variables",children:"Variables"})," - Variable declarations and constants"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/language-guide/collections",children:"Collections"})," - Lists, maps, and sets"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/language-guide/error-handling",children:"Error Handling"})," - Using Result and Optional"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453(e,n,t){t.d(n,{R:()=>l,x:()=>o});var s=t(6540);const r={},i=s.createContext(r);function l(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);