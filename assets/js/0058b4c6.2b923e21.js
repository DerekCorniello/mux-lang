"use strict";(globalThis.webpackChunkmux_website=globalThis.webpackChunkmux_website||[]).push([[849],{6164(e){e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docsSidebar":[{"type":"link","href":"/docs/","label":"Introduction","docId":"index","unlisted":false},{"type":"category","label":"Getting Started","collapsed":false,"items":[{"type":"link","href":"/docs/getting-started/why-mux","label":"Why Mux?","docId":"getting-started/why-mux","unlisted":false},{"type":"link","href":"/docs/getting-started/quick-start","label":"Quick Start","docId":"getting-started/quick-start","unlisted":false}],"collapsible":true},{"type":"category","label":"Language Reference","collapsed":false,"items":[{"type":"link","href":"/docs/reference/overview","label":"Overview","docId":"reference/overview","unlisted":false},{"type":"link","href":"/docs/reference/lexical-structure","label":"Lexical Structure","docId":"reference/lexical-structure","unlisted":false},{"type":"link","href":"/docs/reference/expressions","label":"Expressions","docId":"reference/expressions","unlisted":false},{"type":"link","href":"/docs/reference/statements","label":"Statements","docId":"reference/statements","unlisted":false},{"type":"link","href":"/docs/reference/operators","label":"Operators","docId":"reference/operators","unlisted":false},{"type":"link","href":"/docs/reference/memory-model","label":"Memory Model","docId":"reference/memory-model","unlisted":false}],"collapsible":true},{"type":"category","label":"Language Guide","collapsed":false,"items":[{"type":"link","href":"/docs/language-guide/overview","label":"Overview","docId":"language-guide/overview","unlisted":false},{"type":"link","href":"/docs/language-guide/types","label":"Types","docId":"language-guide/types","unlisted":false},{"type":"link","href":"/docs/language-guide/variables","label":"Variables and Constants","docId":"language-guide/variables","unlisted":false},{"type":"link","href":"/docs/language-guide/operators","label":"Operators","docId":"language-guide/operators","unlisted":false},{"type":"link","href":"/docs/language-guide/functions","label":"Functions","docId":"language-guide/functions","unlisted":false},{"type":"link","href":"/docs/language-guide/control-flow","label":"Control Flow","docId":"language-guide/control-flow","unlisted":false},{"type":"link","href":"/docs/language-guide/classes","label":"Classes","docId":"language-guide/classes","unlisted":false},{"type":"link","href":"/docs/language-guide/enums","label":"Enums / Tagged Unions","docId":"language-guide/enums","unlisted":false},{"type":"link","href":"/docs/language-guide/generics","label":"Generics","docId":"language-guide/generics","unlisted":false},{"type":"link","href":"/docs/language-guide/collections","label":"Collections","docId":"language-guide/collections","unlisted":false},{"type":"link","href":"/docs/language-guide/error-handling","label":"Error Handling","docId":"language-guide/error-handling","unlisted":false},{"type":"link","href":"/docs/language-guide/memory","label":"Memory Management","docId":"language-guide/memory","unlisted":false},{"type":"link","href":"/docs/language-guide/modules","label":"Modules and Imports","docId":"language-guide/modules","unlisted":false}],"collapsible":true},{"type":"category","label":"Design Notes","collapsed":true,"items":[{"type":"link","href":"/docs/design-notes/philosophy","label":"Design Philosophy","docId":"design-notes/philosophy","unlisted":false},{"type":"link","href":"/docs/design-notes/comparisons","label":"Language Comparisons","docId":"design-notes/comparisons","unlisted":false}],"collapsible":true}]},"docs":{"design-notes/comparisons":{"id":"design-notes/comparisons","title":"Language Comparisons","description":"This page shows how Mux approaches common programming tasks compared to Rust, Go, Python, and TypeScript. The goal is clarity, not criticism, each language makes different tradeoffs.","sidebar":"docsSidebar"},"design-notes/philosophy":{"id":"design-notes/philosophy","title":"Design Philosophy","description":"Mux is built on clear principles that guide every design decision. This page explains the \\"why\\" behind Mux\'s design.","sidebar":"docsSidebar"},"getting-started/quick-start":{"id":"getting-started/quick-start","title":"Quick Start","description":"Get up and running with Mux in just a few minutes.","sidebar":"docsSidebar"},"getting-started/why-mux":{"id":"getting-started/why-mux","title":"Why Mux?","description":"The Origin Story","sidebar":"docsSidebar"},"index":{"id":"index","title":"Welcome to Mux","description":"Mux is a statically-typed, reference-counted programming language that combines Go-like minimalism with Rust-inspired safety.","sidebar":"docsSidebar"},"language-guide/classes":{"id":"language-guide/classes","title":"Classes","description":"Mux provides object-oriented programming through classes and interfaces (traits).","sidebar":"docsSidebar"},"language-guide/collections":{"id":"language-guide/collections","title":"Collections","description":"Mux provides three main collection types: lists, maps, and sets, with Python-style literal syntax.","sidebar":"docsSidebar"},"language-guide/control-flow":{"id":"language-guide/control-flow","title":"Control Flow","description":"Mux provides familiar control flow constructs with some unique features like pattern matching with guards.","sidebar":"docsSidebar"},"language-guide/enums":{"id":"language-guide/enums","title":"Enums / Tagged Unions","description":"Enums in Mux are tagged unions (also called algebraic data types or sum types) that can hold different variants with associated data.","sidebar":"docsSidebar"},"language-guide/error-handling":{"id":"language-guide/error-handling","title":"Error Handling","description":"Mux uses explicit error handling through the Result&lt;T, E&gt; and Optional&lt;T&gt; types, avoiding exceptions entirely.","sidebar":"docsSidebar"},"language-guide/examples":{"id":"language-guide/examples","title":"Examples","description":"This page provides quick reference examples for common Mux patterns."},"language-guide/functions":{"id":"language-guide/functions","title":"Functions","description":"Mux functions use the func keyword with explicit parameter types and return type declarations in the form of:","sidebar":"docsSidebar"},"language-guide/generics":{"id":"language-guide/generics","title":"Generics","description":"Mux supports generics with type parameters and interface bounds, similar to Go and Rust.","sidebar":"docsSidebar"},"language-guide/memory":{"id":"language-guide/memory","title":"Memory Management","description":"Mux uses automatic reference counting (RC) for deterministic memory management without manual allocation or garbage collection.","sidebar":"docsSidebar"},"language-guide/modules":{"id":"language-guide/modules","title":"Modules and Imports","description":"Mux uses Python-style imports for code organization and reuse.","sidebar":"docsSidebar"},"language-guide/operators":{"id":"language-guide/operators","title":"Operators","description":"Mux provides a comprehensive set of operators for arithmetic, comparison, logical operations, and more.","sidebar":"docsSidebar"},"language-guide/overview":{"id":"language-guide/overview","title":"Overview","description":"Mux is a statically-typed, reference-counted programming language combining simplicity with safety.","sidebar":"docsSidebar"},"language-guide/types":{"id":"language-guide/types","title":"Types","description":"Mux uses strict static typing with NO implicit type conversions. All type conversions must be explicit using conversion methods.","sidebar":"docsSidebar"},"language-guide/variables":{"id":"language-guide/variables","title":"Variables and Constants","description":"Mux supports both explicit type declarations and type inference with the auto keyword.","sidebar":"docsSidebar"},"reference/expressions":{"id":"reference/expressions","title":"Expressions","description":"This document describes expression evaluation rules in Mux.","sidebar":"docsSidebar"},"reference/lexical-structure":{"id":"reference/lexical-structure","title":"Lexical Structure","description":"This document describes the low-level lexical structure of Mux: tokens, keywords, identifiers, literals, and comments.","sidebar":"docsSidebar"},"reference/memory-model":{"id":"reference/memory-model","title":"Memory Model","description":"Mux uses reference counting for deterministic memory management. This document describes the memory model in detail.","sidebar":"docsSidebar"},"reference/operators":{"id":"reference/operators","title":"Operators","description":"This document describes all operators in Mux, including their precedence, associativity, and behavior.","sidebar":"docsSidebar"},"reference/overview":{"id":"reference/overview","title":"Overview","description":"This section provides detailed, technical documentation of Mux\'s syntax and semantics.","sidebar":"docsSidebar"},"reference/statements":{"id":"reference/statements","title":"Statements","description":"This document describes the semantics of each statement type in Mux.","sidebar":"docsSidebar"}}}}')}}]);