"use strict";(globalThis.webpackChunkmux_website=globalThis.webpackChunkmux_website||[]).push([[402],{1371(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"reference/type-system","title":"Type System","description":"Mux uses a strong, static type system with explicit typing and local type inference.","source":"@site/docs/reference/type-system.md","sourceDirName":"reference","slug":"/reference/type-system","permalink":"/docs/reference/type-system","draft":false,"unlisted":false,"editUrl":"https://github.com/derekcorniello/mux-lang/tree/main/mux-website/docs/reference/type-system.md","tags":[],"version":"current","frontMatter":{}}');var r=i(4848),t=i(8453);const l={},d="Type System",c={},o=[{value:"Type Safety",id:"type-safety",level:2},{value:"Primitive Types",id:"primitive-types",level:2},{value:"Integer Type (<code>int</code>)",id:"integer-type-int",level:3},{value:"Float Type (<code>float</code>)",id:"float-type-float",level:3},{value:"Boolean Type (<code>bool</code>)",id:"boolean-type-bool",level:3},{value:"Character Type (<code>char</code>)",id:"character-type-char",level:3},{value:"String Type (<code>string</code>)",id:"string-type-string",level:3},{value:"Void Type (<code>void</code>)",id:"void-type-void",level:3},{value:"Composite Types",id:"composite-types",level:2},{value:"Optional Type (<code>Optional&lt;T&gt;</code>)",id:"optional-type-optionalt",level:3},{value:"Result Type (<code>Result&lt;T, E&gt;</code>)",id:"result-type-resultt-e",level:3},{value:"List Type (<code>list&lt;T&gt;</code>)",id:"list-type-listt",level:3},{value:"Map Type (<code>map&lt;K, V&gt;</code>)",id:"map-type-mapk-v",level:3},{value:"Set Type (<code>set&lt;T&gt;</code>)",id:"set-type-sett",level:3},{value:"Reference Types",id:"reference-types",level:2},{value:"Reference (<code>&amp;T</code>)",id:"reference-t",level:3},{value:"User-Defined Types",id:"user-defined-types",level:2},{value:"Enums (Tagged Unions)",id:"enums-tagged-unions",level:3},{value:"Classes",id:"classes",level:3},{value:"Interfaces",id:"interfaces",level:3},{value:"Type Conversions",id:"type-conversions",level:2},{value:"Numeric Conversions",id:"numeric-conversions",level:3},{value:"Boolean Conversions",id:"boolean-conversions",level:3},{value:"Character Conversions",id:"character-conversions",level:3},{value:"String Conversions",id:"string-conversions",level:3},{value:"Invalid Conversions",id:"invalid-conversions",level:3},{value:"Type Inference",id:"type-inference",level:2},{value:"Where Inference Works",id:"where-inference-works",level:3},{value:"Where Inference Does NOT Work",id:"where-inference-does-not-work",level:3},{value:"Generics",id:"generics",level:2},{value:"Generic Functions",id:"generic-functions",level:3},{value:"Generic Classes",id:"generic-classes",level:3},{value:"Type Constraints",id:"type-constraints",level:3},{value:"Built-in Interfaces",id:"built-in-interfaces",level:2},{value:"Operator Interface Mapping",id:"operator-interface-mapping",level:3},{value:"Type Equality and Compatibility",id:"type-equality-and-compatibility",level:2},{value:"Nominal Typing",id:"nominal-typing",level:3},{value:"Structural Compatibility for Generics",id:"structural-compatibility-for-generics",level:3},{value:"Type Representations",id:"type-representations",level:2},{value:"TypeNode",id:"typenode",level:3},{value:"Type",id:"type",level:3},{value:"LLVM Type",id:"llvm-type",level:3},{value:"Monomorphization",id:"monomorphization",level:2},{value:"See Also",id:"see-also",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"type-system",children:"Type System"})}),"\n",(0,r.jsx)(n.p,{children:"Mux uses a strong, static type system with explicit typing and local type inference."}),"\n",(0,r.jsx)(n.h2,{id:"type-safety",children:"Type Safety"}),"\n",(0,r.jsxs)(n.p,{children:["Mux enforces ",(0,r.jsx)(n.strong,{children:"strict static typing"})," with ",(0,r.jsx)(n.strong,{children:"no implicit type conversions"}),". All type conversions must be explicit."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"// ERROR: implicit conversion not allowed\nauto x = 1 + 1.0           // Cannot add int and float\n\n// Valid: explicit conversion\nauto x = 1 + (1.0).to_int()   // 2\nauto y = (1).to_float() + 1.0 // 2.0\n"})}),"\n",(0,r.jsx)(n.h2,{id:"primitive-types",children:"Primitive Types"}),"\n",(0,r.jsxs)(n.h3,{id:"integer-type-int",children:["Integer Type (",(0,r.jsx)(n.code,{children:"int"}),")"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"64-bit signed integer"}),"\n",(0,r.jsx)(n.li,{children:"Range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"float-type-float",children:["Float Type (",(0,r.jsx)(n.code,{children:"float"}),")"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"64-bit IEEE-754 floating point"}),"\n",(0,r.jsx)(n.li,{children:"Range: ~\xb11.7E308 with ~15 decimal digits of precision"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"boolean-type-bool",children:["Boolean Type (",(0,r.jsx)(n.code,{children:"bool"}),")"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Two values: ",(0,r.jsx)(n.code,{children:"true"})," and ",(0,r.jsx)(n.code,{children:"false"})]}),"\n",(0,r.jsx)(n.li,{children:"Represents logical states"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"character-type-char",children:["Character Type (",(0,r.jsx)(n.code,{children:"char"}),")"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Single Unicode code point"}),"\n",(0,r.jsx)(n.li,{children:"Encoded as UTF-8 internally"}),"\n",(0,r.jsx)(n.li,{children:"Range: U+0000 to U+10FFFF"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"string-type-string",children:["String Type (",(0,r.jsx)(n.code,{children:"string"}),")"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"UTF-8 encoded sequence of characters"}),"\n",(0,r.jsx)(n.li,{children:"Immutable"}),"\n",(0,r.jsx)(n.li,{children:"Variable length"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"void-type-void",children:["Void Type (",(0,r.jsx)(n.code,{children:"void"}),")"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Used for functions that return no value"}),"\n",(0,r.jsx)(n.li,{children:"Cannot be used as a variable type"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"composite-types",children:"Composite Types"}),"\n",(0,r.jsxs)(n.h3,{id:"optional-type-optionalt",children:["Optional Type (",(0,r.jsx)(n.code,{children:"Optional<T>"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Represents a value that may or may not exist:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"Optional<int> maybeValue = Some(42)\nOptional<string> empty = None\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Variants: ",(0,r.jsx)(n.code,{children:"Some(T)"})," and ",(0,r.jsx)(n.code,{children:"None"})]}),"\n",(0,r.jsxs)(n.h3,{id:"result-type-resultt-e",children:["Result Type (",(0,r.jsx)(n.code,{children:"Result<T, E>"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Represents either success with a value or failure with an error:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'Result<int, string> success = Ok(42)\nResult<int, string> failure = Err("error message")\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Variants: ",(0,r.jsx)(n.code,{children:"Ok(T)"})," and ",(0,r.jsx)(n.code,{children:"Err(E)"})]}),"\n",(0,r.jsxs)(n.h3,{id:"list-type-listt",children:["List Type (",(0,r.jsx)(n.code,{children:"list<T>"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Homogeneous collection of elements:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'list<int> numbers = [1, 2, 3, 4, 5]\nlist<string> names = ["Alice", "Bob"]\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"map-type-mapk-v",children:["Map Type (",(0,r.jsx)(n.code,{children:"map<K, V>"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Key-value pairs with unique keys:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'map<string, int> scores = {"Alice": 90, "Bob": 85}\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"set-type-sett",children:["Set Type (",(0,r.jsx)(n.code,{children:"set<T>"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Unique elements with membership testing:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"set<int> unique_numbers = {1, 2, 3, 4, 5}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"reference-types",children:"Reference Types"}),"\n",(0,r.jsxs)(n.h3,{id:"reference-t",children:["Reference (",(0,r.jsx)(n.code,{children:"&T"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Reference to a value:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"int x = 42\nauto r = &x    // Type: &int\n*r = 100       // x is now 100\n"})}),"\n",(0,r.jsx)(n.h2,{id:"user-defined-types",children:"User-Defined Types"}),"\n",(0,r.jsx)(n.h3,{id:"enums-tagged-unions",children:"Enums (Tagged Unions)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"enum Shape {\n    Circle(float radius)\n    Rectangle(float width, float height)\n    Square(float size)\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"classes",children:"Classes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"class Circle is Drawable {\n    float radius\n\n    func area() returns float {\n        return 3.14159 * radius * radius\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"interfaces",children:"Interfaces"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"interface Drawable {\n    func draw() returns void\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"type-conversions",children:"Type Conversions"}),"\n",(0,r.jsxs)(n.p,{children:["All type conversions in Mux are ",(0,r.jsx)(n.strong,{children:"explicit"}),". No implicit conversions exist between any types."]}),"\n",(0,r.jsx)(n.h3,{id:"numeric-conversions",children:"Numeric Conversions"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"From"}),(0,r.jsx)(n.th,{children:"To"}),(0,r.jsx)(n.th,{children:"Method"}),(0,r.jsx)(n.th,{children:"Notes"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_float()"})}),(0,r.jsx)(n.td,{})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_string()"})}),(0,r.jsx)(n.td,{})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_int()"})}),(0,r.jsx)(n.td,{children:"Truncates"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_string()"})}),(0,r.jsx)(n.td,{})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_int()"})}),(0,r.jsx)(n.td,{children:"Identity"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_float()"})}),(0,r.jsx)(n.td,{children:"Identity"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"boolean-conversions",children:"Boolean Conversions"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"From"}),(0,r.jsx)(n.th,{children:"To"}),(0,r.jsx)(n.th,{children:"Method"}),(0,r.jsx)(n.th,{children:"Notes"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_int()"})}),(0,r.jsx)(n.td,{children:"true=1, false=0"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_float()"})}),(0,r.jsx)(n.td,{children:"true=1.0, false=0.0"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"bool"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_string()"})}),(0,r.jsx)(n.td,{children:'"true" or "false"'})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"character-conversions",children:"Character Conversions"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"From"}),(0,r.jsx)(n.th,{children:"To"}),(0,r.jsx)(n.th,{children:"Method"}),(0,r.jsx)(n.th,{children:"Notes"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"char"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_string()"})}),(0,r.jsx)(n.td,{})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"char"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_int()"})}),(0,r.jsx)(n.td,{children:"Only '0'-'9' digits"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"string-conversions",children:"String Conversions"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"From"}),(0,r.jsx)(n.th,{children:"To"}),(0,r.jsx)(n.th,{children:"Method"}),(0,r.jsx)(n.th,{children:"Returns"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"int"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_int()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Result<int, string>"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_float()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Result<float, string>"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:".to_string()"})}),(0,r.jsx)(n.td,{children:"Identity"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"invalid-conversions",children:"Invalid Conversions"}),"\n",(0,r.jsx)(n.p,{children:"The following are compile-time errors:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'// Type mismatches in binary operations\nauto bad1 = 1 + 1.0        // ERROR: cannot add int and float\nauto bad2 = "hello" + 3    // ERROR: cannot add string and int\nauto bad3 = true + false   // ERROR: cannot add bool and bool\n\n// Type mismatches in comparisons\nauto bad4 = 1 < 1.0        // ERROR: cannot compare int and float\nauto bad5 = "a" == 1       // ERROR: cannot compare string and int\n\n// Function argument type mismatches\nfunc takes_string(string s) returns void { }\ntakes_string(123)          // ERROR: expected string, got int\n'})}),"\n",(0,r.jsx)(n.h2,{id:"type-inference",children:"Type Inference"}),"\n",(0,r.jsxs)(n.p,{children:["Mux supports local type inference with the ",(0,r.jsx)(n.code,{children:"auto"})," keyword."]}),"\n",(0,r.jsx)(n.h3,{id:"where-inference-works",children:"Where Inference Works"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'// Variable initialization\nauto x = 42                    // inferred as int\nauto pi = 3.14159              // inferred as float\nauto name = "Mux"              // inferred as string\n\n// Return statements\nfunc get_number() returns int {\n    auto n = 42  // inferred as int\n    return n\n}\n\n// Function return types (cannot infer)\nfunc make_int(int x) returns int {\n    return x  // return type is int, x is int\n}\n\n// Collection literals\nauto numbers = [1, 2, 3]       // inferred as list<int>\nauto names = ["a", "b"]        // inferred as list<string>\n\n// Pattern matching\nmatch result {\n    Ok(value) { auto v = value }  // inferred from Ok(T)\n    Err(_) { }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"where-inference-does-not-work",children:"Where Inference Does NOT Work"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"// Empty collections need explicit type\nlist<int> empty = []           // ERROR with auto\nauto empty = list<int>()       // Valid with explicit constructor\n\n// Uninitialized variables need explicit type\nauto uninit        // ERROR: cannot infer type\nint uninitialized  // Valid\n\n// Function parameters must be explicit\nfunc process(auto item) returns void { }  // ERROR\nfunc process(int item) returns void { }    // Valid\n\n// Generic instantiation may need explicit type\nStack<int> stack = Stack<int>.new()  // Explicit for clarity\n"})}),"\n",(0,r.jsx)(n.h2,{id:"generics",children:"Generics"}),"\n",(0,r.jsx)(n.p,{children:"Mux supports generic types and functions with interface bounds."}),"\n",(0,r.jsx)(n.h3,{id:"generic-functions",children:"Generic Functions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'func identity<T>(T value) returns T {\n    return value\n}\n\nauto a = identity(42)           // identity$$int\nauto b = identity("hello")      // identity$$string\n'})}),"\n",(0,r.jsx)(n.h3,{id:"generic-classes",children:"Generic Classes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"class Stack<T> {\n    list<T> items\n\n    func push(T item) returns void {\n        items.push_back(item)\n    }\n\n    func pop() returns Optional<T> {\n        if items.is_empty() { return None }\n        return items.pop_back()\n    }\n}\n\nauto int_stack = Stack<int>.new()\nauto string_stack = Stack<string>.new()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"type-constraints",children:"Type Constraints"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"// Single bound\nfunc max<T is Comparable>(T a, T b) returns T {\n    if a > b { return a }\n    return b\n}\n\n// Multiple bounds (AND semantics)\nfunc combine<T is Add & Stringable>(T a, T b) returns string {\n    return (a.add(b)).to_string()\n}\n\n// Explicit type instantiation\nauto result = max<int>(3, 7)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"built-in-interfaces",children:"Built-in Interfaces"}),"\n",(0,r.jsx)(n.p,{children:"Mux provides built-in interfaces for common operations:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Interface"}),(0,r.jsx)(n.th,{children:"Methods"}),(0,r.jsx)(n.th,{children:"Types Supporting"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Stringable"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"to_string() -> string"})}),(0,r.jsx)(n.td,{children:"int, float, bool, char, string, collections, enums, classes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Add"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"add(Self) -> Self"})}),(0,r.jsx)(n.td,{children:"int, float, string"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Sub"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"sub(Self) -> Self"})}),(0,r.jsx)(n.td,{children:"int, float"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Mul"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"mul(Self) -> Self"})}),(0,r.jsx)(n.td,{children:"int, float"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Div"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"div(Self) -> Self"})}),(0,r.jsx)(n.td,{children:"int, float"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Arithmetic"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"add"}),", ",(0,r.jsx)(n.code,{children:"sub"}),", ",(0,r.jsx)(n.code,{children:"mul"}),", ",(0,r.jsx)(n.code,{children:"div"})]}),(0,r.jsx)(n.td,{children:"int, float"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Equatable"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"eq(Self) -> bool"})}),(0,r.jsx)(n.td,{children:"All types except functions"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Comparable"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"cmp(Self) -> int"})}),(0,r.jsx)(n.td,{children:"int, float, string"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"operator-interface-mapping",children:"Operator Interface Mapping"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Operator"}),(0,r.jsx)(n.th,{children:"Interface Method"}),(0,r.jsx)(n.th,{children:"Primitive Behavior"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"a + b"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Add.add()"})}),(0,r.jsx)(n.td,{children:"Direct LLVM addition"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"a - b"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Sub.sub()"})}),(0,r.jsx)(n.td,{children:"Direct LLVM subtraction"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"a * b"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Mul.mul()"})}),(0,r.jsx)(n.td,{children:"Direct LLVM multiplication"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"a / b"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Div.div()"})}),(0,r.jsx)(n.td,{children:"Direct LLVM division"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"a == b"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Equatable.eq()"})}),(0,r.jsx)(n.td,{children:"Direct LLVM comparison"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"a > b"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Comparable.cmp()"})}),(0,r.jsx)(n.td,{children:"Comparison via cmp"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"type-equality-and-compatibility",children:"Type Equality and Compatibility"}),"\n",(0,r.jsx)(n.h3,{id:"nominal-typing",children:"Nominal Typing"}),"\n",(0,r.jsx)(n.p,{children:"Mux uses nominal typing for user-defined types:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:"enum A { First(int) }\nenum B { First(int) }\n\nauto a = A.First(1)\nauto b = B.First(1)\n// a == b  // ERROR: different types\n"})}),"\n",(0,r.jsx)(n.h3,{id:"structural-compatibility-for-generics",children:"Structural Compatibility for Generics"}),"\n",(0,r.jsx)(n.p,{children:"Generic types are compatible when type parameters are compatible:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'func process<T is Equatable>(list<T> items) returns void { }\n\nfunc main() returns void {\n    auto ints = [1, 2, 3]\n    auto strs = ["a", "b", "c"]\n    process(ints)   // OK: int is Equatable\n    process(strs)    // OK: string is Equatable\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"type-representations",children:"Type Representations"}),"\n",(0,r.jsx)(n.p,{children:"The compiler maintains three distinct type representations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"TypeNode (AST) \u2500\u2500semantic analysis\u2500\u2500\u25ba Type \u2500\u2500code generation\u2500\u2500\u25ba LLVM Type\n     \u2502                                      \u2502\n  Source location                      Semantic analysis\n  Pretty printing                      Type resolution\n"})}),"\n",(0,r.jsx)(n.h3,{id:"typenode",children:"TypeNode"}),"\n",(0,r.jsx)(n.p,{children:"Used in the AST for parsing and error reporting:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Source file location"}),"\n",(0,r.jsx)(n.li,{children:"Pretty-printed representation"}),"\n",(0,r.jsx)(n.li,{children:"Generic type parameters"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"type",children:"Type"}),"\n",(0,r.jsx)(n.p,{children:"Used for semantic analysis:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Resolved type information"}),"\n",(0,r.jsx)(n.li,{children:"Interface implementations"}),"\n",(0,r.jsx)(n.li,{children:"Generic instantiation"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"llvm-type",children:"LLVM Type"}),"\n",(0,r.jsx)(n.p,{children:"Used for code generation:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"BasicTypeEnum"})," for value types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"PointerType"})," for references"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"StructType"})," for enums and classes"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"monomorphization",children:"Monomorphization"}),"\n",(0,r.jsx)(n.p,{children:"Mux uses compile-time monomorphization for generics:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mux",children:'func identity<T>(T value) returns T {\n    return value\n}\n\nauto a = identity(42)        // Generates: identity$$int\nauto b = identity("hello")    // Generates: identity$$string\n'})}),"\n",(0,r.jsx)(n.p,{children:"The compiler:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Infers concrete types from function arguments"}),"\n",(0,r.jsx)(n.li,{children:"Generates unique names for specialized functions"}),"\n",(0,r.jsx)(n.li,{children:"Substitutes type parameters with concrete types"}),"\n",(0,r.jsx)(n.li,{children:"Caches generated code to avoid regeneration"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/reference/lexical-structure",children:"Lexical Structure"})," - Type literals in source"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/reference/grammar",children:"Grammar"})," - Type syntax"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/reference/operators",children:"Operators"})," - Type operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/language-guide/generics",children:"Generics"})," - Generic programming guide"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453(e,n,i){i.d(n,{R:()=>l,x:()=>d});var s=i(6540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);