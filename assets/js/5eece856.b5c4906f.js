"use strict";(globalThis.webpackChunkmux_website=globalThis.webpackChunkmux_website||[]).push([[811],{9354(n,e,t){t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"language-guide/enums","title":"Enums / Tagged Unions","description":"Enums in Mux are tagged unions (also called algebraic data types or sum types) that can hold different variants with associated data.","source":"@site/docs/language-guide/enums.md","sourceDirName":"language-guide","slug":"/language-guide/enums","permalink":"/docs/language-guide/enums","draft":false,"unlisted":false,"editUrl":"https://github.com/derekcorniello/mux-lang/tree/main/mux-website/docs/language-guide/enums.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Classes","permalink":"/docs/language-guide/classes"},"next":{"title":"Generics","permalink":"/docs/language-guide/generics"}}');var s=t(4848),r=t(8453);const a={},l="Enums / Tagged Unions",o={},c=[{value:"Basic Enum Definition",id:"basic-enum-definition",level:2},{value:"Creating Enum Instances",id:"creating-enum-instances",level:2},{value:"Pattern Matching with Enums",id:"pattern-matching-with-enums",level:2},{value:"Ignoring Associated Data",id:"ignoring-associated-data",level:3},{value:"Pattern Matching with Guards",id:"pattern-matching-with-guards",level:2},{value:"Generic Enums",id:"generic-enums",level:2},{value:"Common Enum Patterns",id:"common-enum-patterns",level:2},{value:"Optional Values",id:"optional-values",level:3},{value:"Result Types for Error Handling",id:"result-types-for-error-handling",level:3},{value:"State Machines",id:"state-machines",level:3},{value:"Nested Enums",id:"nested-enums",level:3},{value:"Enums in Collections",id:"enums-in-collections",level:2},{value:"Exhaustiveness Checking",id:"exhaustiveness-checking",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"enums--tagged-unions",children:"Enums / Tagged Unions"})}),"\n",(0,s.jsx)(e.p,{children:"Enums in Mux are tagged unions (also called algebraic data types or sum types) that can hold different variants with associated data."}),"\n",(0,s.jsx)(e.h2,{id:"basic-enum-definition",children:"Basic Enum Definition"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mux",metastring:'title="basic_enum.mux"',children:"enum Status {\n    Pending\n    Active\n    Completed\n}\n\nenum Shape {\n    Circle(float radius)\n    Rectangle(float width, float height)\n    Square(float size)\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Key Points:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Each variant is a case of the enum"}),"\n",(0,s.jsx)(e.li,{children:"Variants can carry associated data (or none)"}),"\n",(0,s.jsxs)(e.li,{children:["Variants are constructed using ",(0,s.jsx)(e.code,{children:".new()"})," syntax"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"creating-enum-instances",children:"Creating Enum Instances"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mux",metastring:'title="creating_enums.mux"',children:"// Variant without data\nauto status = Pending.new()\n\n// Variants with data\nauto circle = Circle.new(5.0)\nauto rect = Rectangle.new(10.0, 20.0)\nauto square = Square.new(7.5)\n\n// Type inference\nauto myShape = Circle.new(5.0)  // type inferred as Shape\n"})}),"\n",(0,s.jsx)(e.h2,{id:"pattern-matching-with-enums",children:"Pattern Matching with Enums"}),"\n",(0,s.jsxs)(e.p,{children:["Use ",(0,s.jsx)(e.code,{children:"match"})," to handle different enum variants:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mux",metastring:'title="pattern_matching_enums.mux"',children:'enum Shape {\n    Circle(float radius)\n    Rectangle(float width, float height)\n    Square(float size)\n}\n\nauto myShape = Circle.new(5.0)\n\nmatch myShape {\n    Circle(r) {\n        auto area = 3.1415 * r * r\n        print("Circle area: " + area.to_string())\n    }\n    Rectangle(w, h) {\n        auto area = w * h\n        print("Rectangle area: " + area.to_string())\n    }\n    Square(s) {\n        auto area = s * s\n        print("Square area: " + area.to_string())\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"ignoring-associated-data",children:"Ignoring Associated Data"}),"\n",(0,s.jsxs)(e.p,{children:["Use ",(0,s.jsx)(e.code,{children:"_"})," to ignore data you don't need:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mux",metastring:'title="ignoring_enum_data.mux"',children:'match shape {\n    Circle(_) {\n        print("It\'s a circle")  // radius ignored\n    }\n    Rectangle(width, _) {\n        print("Rectangle with width: " + width.to_string())  // height ignored\n    }\n    Square(size) {\n        print("Square with size: " + size.to_string())\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"pattern-matching-with-guards",children:"Pattern Matching with Guards"}),"\n",(0,s.jsx)(e.p,{children:"Add conditional logic with guards:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mux",metastring:'title="enum_guards.mux"',children:'enum MaybeValue<T> {\n    Some(T)\n    None\n}\n\nauto value = Some.new(42)\n\nmatch value {\n    Some(v) if v > 10 {\n        print("Large value: " + v.to_string())\n    }\n    Some(v) if v > 0 {\n        print("Small positive: " + v.to_string())\n    }\n    Some(v) {\n        print("Non-positive: " + v.to_string())\n    }\n    None {\n        print("No value")\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"generic-enums",children:"Generic Enums"}),"\n",(0,s.jsx)(e.p,{children:"Enums can be generic over type parameters:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mux",metastring:'title="enum_generics.mux"',children:'enum Option<T> {\n    Some(T)\n    None\n}\n\nenum Result<T, E> {\n    Ok(T)\n    Err(E)\n}\n\n// Usage\nauto maybeInt = Some.new(42)         // Option<int>\nauto maybeStr = Some.new("hello")    // Option<string>\nauto nothing = None.new()             // Option<T> (generic)\n\nauto success = Ok.new(100)            // Result<int, E>\nauto failure = Err.new("error msg")   // Result<T, string>\n'})}),"\n",(0,s.jsx)(e.h2,{id:"common-enum-patterns",children:"Common Enum Patterns"}),"\n",(0,s.jsx)(e.h3,{id:"optional-values",children:"Optional Values"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mux",metastring:'title="optional_values.mux"',children:'enum Optional<T> {\n    Some(T)\n    None\n}\n\nfunc findFirst(list<int> items, int target) returns Optional<int> {\n    for i in range(0, items.size()) {\n        if items[i] == target {\n            return Some.new(i)\n        }\n    }\n    return None.new()\n}\n\nauto result = findFirst([10, 20, 30], 20)\n\nmatch result {\n    Some(index) {\n        print("Found at index: " + index.to_string())\n    }\n    None {\n        print("Not found")\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"result-types-for-error-handling",children:"Result Types for Error Handling"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mux",metastring:'title="result_types.mux"',children:'enum Result<T, E> {\n    Ok(T)\n    Err(E)\n}\n\nfunc divide(int a, int b) returns Result<int, string> {\n    if b == 0 {\n        return Err.new("division by zero")\n    }\n    return Ok.new(a / b)\n}\n\nauto result = divide(10, 2)\n\nmatch result {\n    Ok(value) {\n        print("Result: " + value.to_string())\n    }\n    Err(error) {\n        print("Error: " + error)\n    }\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["See ",(0,s.jsx)(e.a,{href:"/docs/language-guide/error-handling",children:"Error Handling"})," for more details on Result and Optional."]}),"\n",(0,s.jsx)(e.h3,{id:"state-machines",children:"State Machines"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mux",metastring:'title="state_machines.mux"',children:'enum Connection {\n    Disconnected\n    Connecting(string address)\n    Connected(string address, int port)\n    Failed(string error)\n}\n\nfunc handleConnection(Connection conn) returns void {\n    match conn {\n        Disconnected {\n            print("Not connected")\n        }\n        Connecting(addr) {\n            print("Connecting to: " + addr)\n        }\n        Connected(addr, port) {\n            print("Connected to " + addr + ":" + port.to_string())\n        }\n        Failed(err) {\n            print("Connection failed: " + err)\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"nested-enums",children:"Nested Enums"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mux",metastring:'title="nested_enums.mux"',children:'enum Message {\n    Text(string content)\n    Image(string url, int width, int height)\n    Reply(string content, int replyToId)\n}\n\nenum Event {\n    MessageReceived(Message msg)\n    UserJoined(string username)\n    UserLeft(string username)\n}\n\nauto event = MessageReceived.new(Text.new("Hello!"))\n\nmatch event {\n    MessageReceived(msg) {\n        match msg {\n            Text(content) {\n                print("Text: " + content)\n            }\n            Image(url, w, h) {\n                print("Image: " + url)\n            }\n            Reply(content, id) {\n                print("Reply to " + id.to_string() + ": " + content)\n            }\n        }\n    }\n    UserJoined(name) {\n        print(name + " joined")\n    }\n    UserLeft(name) {\n        print(name + " left")\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"enums-in-collections",children:"Enums in Collections"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mux",metastring:'title="enums_in_collections.mux"',children:'enum Shape {\n    Circle(float radius)\n    Rectangle(float width, float height)\n    Square(float size)\n}\n\n// List of shapes\nlist<Shape> shapes = [\n    Circle.new(1.0),\n    Rectangle.new(2.0, 3.0),\n    Square.new(4.0)\n]\n\nfor Shape shape in shapes {\n    match shape {\n        Circle(r) {\n            print("Circle: " + r.to_string())\n        }\n        Rectangle(w, h) {\n            print("Rectangle: " + w.to_string() + "x" + h.to_string())\n        }\n        Square(s) {\n            print("Square: " + s.to_string())\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"exhaustiveness-checking",children:"Exhaustiveness Checking"}),"\n",(0,s.jsx)(e.p,{children:"Mux enforces exhaustive pattern matching - all variants must be covered:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-mux",metastring:'title="exhaustiveness_checking.mux"',children:'enum Color {\n    Red\n    Green\n    Blue\n}\n\n// ERROR: Non-exhaustive match (missing Blue)\nmatch color {\n    Red { print("red") }\n    Green { print("green") }\n    // Blue case missing!\n}\n\n// Correct: All variants covered\nmatch color {\n    Red { print("red") }\n    Green { print("green") }\n    Blue { print("blue") }\n}\n\n// Correct: Using wildcard for catch-all\nmatch color {\n    Red { print("red") }\n    _ { print("other color") }  // Covers Green and Blue\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use enums for mutually exclusive states"})," - Better than multiple booleans"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Match exhaustively"})," - Don't overuse wildcard patterns"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use guards for additional logic"})," - Cleaner than nested if statements"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsxs)(e.strong,{children:["Ignore unused data with ",(0,s.jsx)(e.code,{children:"_"})]})," - Makes intent explicit"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Prefer Result over exceptions"})," - Explicit error handling"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Prefer Optional over null"})," - No null pointer errors"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use generic enums for reusable patterns"})," - Option<T>, Result<T, E>"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"/docs/language-guide/error-handling",children:"Error Handling"})," - Result and Optional types"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"/docs/language-guide/control-flow",children:"Control Flow"})," - Pattern matching with match"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"/docs/language-guide/generics",children:"Generics"})," - Generic enums"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"/docs/language-guide/collections",children:"Collections"})," - Enums in lists and maps"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453(n,e,t){t.d(e,{R:()=>a,x:()=>l});var i=t(6540);const s={},r=i.createContext(s);function a(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);