"use strict";(globalThis.webpackChunkmux_website=globalThis.webpackChunkmux_website||[]).push([[229],{9910(e,n,r){r.r(n),r.d(n,{assets:()=>t,contentTitle:()=>a,default:()=>u,frontMatter:()=>l,metadata:()=>c,toc:()=>o});const c=JSON.parse('{"id":"language-guide/memory","title":"Memory Management","description":"Mux uses automatic reference counting (RC) for deterministic memory management without manual allocation or garbage collection.","source":"@site/docs/language-guide/memory.md","sourceDirName":"language-guide","slug":"/language-guide/memory","permalink":"/docs/language-guide/memory","draft":false,"unlisted":false,"editUrl":"https://github.com/derekcorniello/mux-lang/tree/main/mux-website/docs/language-guide/memory.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Error Handling","permalink":"/docs/language-guide/error-handling"},"next":{"title":"Modules and Imports","permalink":"/docs/language-guide/modules"}}');var s=r(4848),i=r(8453);const l={},a="Memory Management",t={},o=[{value:"Overview",id:"overview",level:2},{value:"Memory Safety",id:"memory-safety",level:2},{value:"No Null Pointers",id:"no-null-pointers",level:3},{value:"No Manual Memory Management",id:"no-manual-memory-management",level:3},{value:"No Use-After-Free",id:"no-use-after-free",level:3},{value:"Reference Counting Basics",id:"reference-counting-basics",level:2},{value:"Memory Layout",id:"memory-layout",level:2},{value:"Automatic Cleanup",id:"automatic-cleanup",level:2},{value:"Scope-Based Cleanup",id:"scope-based-cleanup",level:3},{value:"Early Returns",id:"early-returns",level:3},{value:"Reference Count Operations",id:"reference-count-operations",level:2},{value:"Increment (<code>mux_rc_inc</code>)",id:"increment-mux_rc_inc",level:3},{value:"Decrement (<code>mux_rc_dec</code>)",id:"decrement-mux_rc_dec",level:3},{value:"Collections and Reference Counting",id:"collections-and-reference-counting",level:2},{value:"Nested Collections",id:"nested-collections",level:3},{value:"Objects and Reference Counting",id:"objects-and-reference-counting",level:2},{value:"Scope Tracking",id:"scope-tracking",level:2},{value:"Circular References",id:"circular-references",level:2},{value:"Value vs Reference Semantics",id:"value-vs-reference-semantics",level:2},{value:"Primitives (Value Semantics)",id:"primitives-value-semantics",level:3},{value:"Objects (Reference Semantics)",id:"objects-reference-semantics",level:3},{value:"Collections (Reference Semantics)",id:"collections-reference-semantics",level:3},{value:"References",id:"references",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Atomic Operations",id:"atomic-operations",level:3},{value:"Compared to Garbage Collection",id:"compared-to-garbage-collection",level:3},{value:"Compared to Manual Management",id:"compared-to-manual-management",level:3},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"memory-management",children:"Memory Management"})}),"\n",(0,s.jsxs)(n.p,{children:["Mux uses ",(0,s.jsx)(n.strong,{children:"automatic reference counting"})," (RC) for deterministic memory management without manual allocation or garbage collection."]}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Mux's memory model provides:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["No manual ",(0,s.jsx)(n.code,{children:"free"})," or ",(0,s.jsx)(n.code,{children:"delete"})]})," - Memory cleaned up automatically"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Deterministic cleanup"})," - Objects freed when reference count reaches zero"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No garbage collection pauses"})," - Predictable performance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Heap allocation"})," - Objects and collections live on the heap"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Value semantics for primitives"})," - Primitives passed by value"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"memory-safety",children:"Memory Safety"}),"\n",(0,s.jsx)(n.h3,{id:"no-null-pointers",children:"No Null Pointers"}),"\n",(0,s.jsxs)(n.p,{children:["Mux has no null pointers. Use ",(0,s.jsx)(n.code,{children:"Optional<T>"})," instead:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="no_null_pointers.mux"',children:'// No null\nOptional<Circle> maybeCircle = None\n\n// Must explicitly handle absence\nmatch maybeCircle {\n    Some(circle) {\n        print(circle.radius.to_string())\n    }\n    None {\n        print("No circle")\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"no-manual-memory-management",children:"No Manual Memory Management"}),"\n",(0,s.jsx)(n.p,{children:"Cannot manually free memory or create dangling pointers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="no_manual_memory.mux"',children:"auto circle = Circle.new(5.0)\n// No way to call free/delete\n// Memory automatically freed when circle goes out of scope\n"})}),"\n",(0,s.jsx)(n.h3,{id:"no-use-after-free",children:"No Use-After-Free"}),"\n",(0,s.jsx)(n.p,{children:"Reference counting prevents use-after-free:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="no_use_after_free.mux"',children:"auto list1 = [1, 2, 3]\nauto list2 = list1    // refcount = 2\n\n// Even if list1 goes out of scope, list2 is still valid\n// Memory not freed until refcount = 0\n"})}),"\n",(0,s.jsx)(n.h2,{id:"reference-counting-basics",children:"Reference Counting Basics"}),"\n",(0,s.jsx)(n.p,{children:"Every heap-allocated value has a reference count that tracks how many references point to it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="reference_counting.mux"',children:"// Create object (refcount = 1)\nauto circle1 = Circle.new(5.0)\n\n// Create another reference (refcount = 2)\nauto circle2 = circle1\n\n// circle2 goes out of scope (refcount = 1)\n// circle1 goes out of scope (refcount = 0, memory freed)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"memory-layout",children:"Memory Layout"}),"\n",(0,s.jsxs)(n.p,{children:["All heap-allocated values use a reference counting header. The ",(0,s.jsx)(n.code,{children:"RefHeader"})," uses ",(0,s.jsx)(n.code,{children:"AtomicUsize"})," for thread-safe atomic operations."]}),"\n",(0,s.jsx)(n.h2,{id:"automatic-cleanup",children:"Automatic Cleanup"}),"\n",(0,s.jsx)(n.h3,{id:"scope-based-cleanup",children:"Scope-Based Cleanup"}),"\n",(0,s.jsx)(n.p,{children:"Variables are cleaned up when they go out of scope:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="scope_cleanup.mux"',children:"func example() returns void {\n    auto nums = [1, 2, 3]      // Allocated (refcount = 1)\n    \n    if true {\n        auto temp = nums       // refcount = 2\n        print(temp.size().to_string())\n    }  // temp goes out of scope (refcount = 1)\n    \n    print(nums.size().to_string())\n}  // nums goes out of scope (refcount = 0, freed)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"early-returns",children:"Early Returns"}),"\n",(0,s.jsx)(n.p,{children:"Cleanup happens even with early returns:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="early_return_cleanup.mux"',children:'func process(int value) returns Result<int, string> {\n    auto data = [1, 2, 3, 4, 5]  // Allocated\n    \n    if value < 0 {\n        return Err("negative")    // data cleaned up before return\n    }\n    \n    if value > 100 {\n        return Err("too large")   // data cleaned up before return\n    }\n    \n    return Ok(value)\n}  // data cleaned up at end\n'})}),"\n",(0,s.jsx)(n.h2,{id:"reference-count-operations",children:"Reference Count Operations"}),"\n",(0,s.jsxs)(n.h3,{id:"increment-mux_rc_inc",children:["Increment (",(0,s.jsx)(n.code,{children:"mux_rc_inc"}),")"]}),"\n",(0,s.jsx)(n.p,{children:"Reference count increases when:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Creating a new reference to existing value"}),"\n",(0,s.jsx)(n.li,{children:"Assigning to a new variable"}),"\n",(0,s.jsx)(n.li,{children:"Passing as a function argument"}),"\n",(0,s.jsx)(n.li,{children:"Adding to a collection"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="rc_increment.mux"',children:"auto list1 = [1, 2, 3]    // refcount = 1\nauto list2 = list1        // refcount = 2 (rc_inc called)\nauto list3 = list1        // refcount = 3 (rc_inc called)\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"decrement-mux_rc_dec",children:["Decrement (",(0,s.jsx)(n.code,{children:"mux_rc_dec"}),")"]}),"\n",(0,s.jsx)(n.p,{children:"Reference count decreases when:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Variable goes out of scope"}),"\n",(0,s.jsx)(n.li,{children:"Variable is reassigned"}),"\n",(0,s.jsx)(n.li,{children:"Function returns (cleanup of local variables)"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="rc_decrement.mux"',children:"{\n    auto data = [1, 2, 3]     // refcount = 1\n    auto ref = data           // refcount = 2\n}  // ref destroyed (rc_dec, refcount = 1)\n   // data destroyed (rc_dec, refcount = 0, memory freed)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"mux_rc_dec"})," returns ",(0,s.jsx)(n.code,{children:"true"}),", the refcount reached zero and memory is freed automatically."]}),"\n",(0,s.jsx)(n.h2,{id:"collections-and-reference-counting",children:"Collections and Reference Counting"}),"\n",(0,s.jsx)(n.p,{children:"Collections are RC-allocated and contain RC-allocated values:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="collections_rc.mux"',children:"auto nums = [1, 2, 3]         // list refcount = 1\n                              // each int is boxed with refcount = 1\n\nauto nums2 = nums             // list refcount = 2\n                              // ints' refcounts unchanged (shared)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"nested-collections",children:"Nested Collections"}),"\n",(0,s.jsx)(n.p,{children:"When a collection is freed, all contained values have their refcounts decremented:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="nested_collections_rc.mux"',children:"auto nested = [[1, 2], [3, 4]]\n// Outer list: refcount = 1\n// Inner lists: refcount = 1 each\n// Ints: refcount = 1 each\n\n// When nested is freed:\n// 1. Outer list refcount -> 0, freed\n// 2. Inner lists refcount -> 0, freed\n// 3. Ints refcount -> 0, freed\n"})}),"\n",(0,s.jsx)(n.h2,{id:"objects-and-reference-counting",children:"Objects and Reference Counting"}),"\n",(0,s.jsx)(n.p,{children:"Class instances use reference counting:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="objects_rc.mux"',children:'class Person {\n    string name\n    int age\n}\n\nauto person1 = Person.new()    // refcount = 1\nperson1.name = "Alice"\nperson1.age = 30\n\nauto person2 = person1         // refcount = 2 (same object)\n\nperson2.age = 31\nprint(person1.age.to_string()) // "31" - same object\n'})}),"\n",(0,s.jsx)(n.p,{children:"When all references are gone, the object is freed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="object_cleanup.mux"',children:'{\n    auto p = Person.new()      // refcount = 1\n    p.name = "Bob"\n}  // p goes out of scope, refcount = 0, object freed\n'})}),"\n",(0,s.jsx)(n.h2,{id:"scope-tracking",children:"Scope Tracking"}),"\n",(0,s.jsx)(n.p,{children:"The compiler generates cleanup code using a scope stack:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Enter scope"})," \u2192 ",(0,s.jsx)(n.code,{children:"push_rc_scope()"})," (function entry, if-block, loop-body, match-arm)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Track variable"})," \u2192 ",(0,s.jsx)(n.code,{children:"track_rc_variable(name, alloca)"})," for each RC-allocated variable"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Exit scope"})," \u2192 ",(0,s.jsx)(n.code,{children:"generate_all_scopes_cleanup()"})," iterates through all scopes in reverse order"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This ensures proper cleanup order and handles early returns."}),"\n",(0,s.jsx)(n.h2,{id:"circular-references",children:"Circular References"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Warning:"})," Mux's reference counting cannot automatically break circular references:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="circular_reference.mux"',children:"// CAREFUL: This could create a cycle\nclass Node {\n    int value\n    Optional<Node> next\n}\n\nauto node1 = Node.new()\nauto node2 = Node.new()\n\nnode1.next = Some(node2)\nnode2.next = Some(node1)  // Circular reference!\n\n// These nodes will never be freed automatically\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution:"})," Avoid circular structures, or break cycles manually before scope exit."]}),"\n",(0,s.jsx)(n.h2,{id:"value-vs-reference-semantics",children:"Value vs Reference Semantics"}),"\n",(0,s.jsx)(n.h3,{id:"primitives-value-semantics",children:"Primitives (Value Semantics)"}),"\n",(0,s.jsx)(n.p,{children:"Primitives are passed by value (copied):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="value_semantics.mux"',children:"auto x = 42\nauto y = x     // y is a copy\ny = 100        // x is still 42\n"})}),"\n",(0,s.jsx)(n.h3,{id:"objects-reference-semantics",children:"Objects (Reference Semantics)"}),"\n",(0,s.jsx)(n.p,{children:"Objects are passed by reference (shared):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="reference_semantics.mux"',children:'auto circle1 = Circle.new(5.0)\nauto circle2 = circle1    // Same object, not a copy\n\ncircle2.radius = 10.0\nprint(circle1.radius.to_string())  // "10.0" - same object\n'})}),"\n",(0,s.jsx)(n.h3,{id:"collections-reference-semantics",children:"Collections (Reference Semantics)"}),"\n",(0,s.jsx)(n.p,{children:"Collections are passed by reference:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="collections_reference.mux"',children:'auto list1 = [1, 2, 3]\nauto list2 = list1    // Same list, not a copy\n\nlist2.push_back(4)\nprint(list1.size().to_string())  // "4" - same list\n'})}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsx)(n.p,{children:"Mux supports explicit references for passing values by reference:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mux",metastring:'title="memory_refs.mux"',children:'// Basic reference usage\nint x = 10\nauto r = &x      // r is of type &int\nprint("ref value: " + (*r).to_string())  // 10 - explicit dereference with *\n\n*r = 20          // Changes x to 20 via dereference\nprint("x is now: " + x.to_string())  // 20\n\n// Function taking a reference\nfunc update(&int ref) returns void {\n    *ref = *ref + 1  // Must explicitly dereference to modify\n}\n\nupdate(&x)\nprint("val after update: " + x.to_string())  // 21\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Reference Syntax:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Create reference: ",(0,s.jsx)(n.code,{children:"&variable"})," or ",(0,s.jsx)(n.code,{children:"&expression"})]}),"\n",(0,s.jsxs)(n.li,{children:["Dereference: ",(0,s.jsx)(n.code,{children:"*reference"})," (required for both reading and writing)"]}),"\n",(0,s.jsxs)(n.li,{children:["Pass to functions: ",(0,s.jsx)(n.code,{children:"func(&int ref)"})," declares parameter, ",(0,s.jsx)(n.code,{children:"update(&x)"})," passes reference"]}),"\n",(0,s.jsx)(n.li,{children:"References to references: Not supported"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Design Note:"})," Unlike some languages with automatic dereferencing, Mux requires explicit ",(0,s.jsx)(n.code,{children:"*"})," for all reference operations. This makes memory access patterns explicit."]}),"\n",(0,s.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsx)(n.h3,{id:"atomic-operations",children:"Atomic Operations"}),"\n",(0,s.jsx)(n.p,{children:"Reference counting uses atomic operations for thread safety:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Overhead"}),": Atomic increment/decrement on each reference change"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cache"}),": Reference count header may cause cache misses"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"compared-to-garbage-collection",children:"Compared to Garbage Collection"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Deterministic cleanup (no GC pauses)"}),"\n",(0,s.jsx)(n.li,{children:"Predictable performance"}),"\n",(0,s.jsx)(n.li,{children:"Lower memory overhead (no GC metadata)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Tradeoffs:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Cannot break circular references automatically"}),"\n",(0,s.jsx)(n.li,{children:"Atomic operations have cost"}),"\n",(0,s.jsx)(n.li,{children:"Must track references carefully"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"compared-to-manual-management",children:"Compared to Manual Management"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["No manual ",(0,s.jsx)(n.code,{children:"free"})," calls"]}),"\n",(0,s.jsx)(n.li,{children:"No use-after-free bugs"}),"\n",(0,s.jsx)(n.li,{children:"No double-free bugs"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Tradeoffs:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Cannot control exact deallocation time"}),"\n",(0,s.jsx)(n.li,{children:"Reference count overhead"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/language-guide/types",children:"Types"})," - Value types and boxing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/language-guide/classes",children:"Classes"})," - Object lifecycle"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/language-guide/collections",children:"Collections"})," - Collection memory management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/docs/language-guide/error-handling",children:"Error Handling"})," - Optional and Result"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453(e,n,r){r.d(n,{R:()=>l,x:()=>a});var c=r(6540);const s={},i=c.createContext(s);function l(e){const n=c.useContext(i);return c.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),c.createElement(i.Provider,{value:n},e.children)}}}]);