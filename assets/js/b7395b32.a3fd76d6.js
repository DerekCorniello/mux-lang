"use strict";(globalThis.webpackChunkmux_website=globalThis.webpackChunkmux_website||[]).push([[664],{9852(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"language-guide/classes","title":"Classes","description":"Mux provides object-oriented programming through classes and interfaces (traits).","source":"@site/docs/language-guide/classes.md","sourceDirName":"language-guide","slug":"/language-guide/classes","permalink":"/docs/language-guide/classes","draft":false,"unlisted":false,"editUrl":"https://github.com/derekcorniello/mux-lang/tree/main/mux-website/docs/language-guide/classes.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Control Flow","permalink":"/docs/language-guide/control-flow"},"next":{"title":"Enums / Tagged Unions","permalink":"/docs/language-guide/enums"}}');var i=s(4848),r=s(8453);const c={},a="Classes",l={},o=[{value:"Basic Class Definition",id:"basic-class-definition",level:2},{value:"Class Instantiation",id:"class-instantiation",level:2},{value:"Interfaces (Traits)",id:"interfaces-traits",level:2},{value:"Implementing Interfaces",id:"implementing-interfaces",level:2},{value:"Methods",id:"methods",level:2},{value:"Instance Methods",id:"instance-methods",level:3},{value:"Methods with Unused Parameters",id:"methods-with-unused-parameters",level:3},{value:"Static Methods with <code>common</code>",id:"static-methods-with-common",level:2},{value:"<code>common</code> vs <code>const</code>",id:"common-vs-const",level:3},{value:"Constants in Classes",id:"constants-in-classes",level:2},{value:"Generic Classes",id:"generic-classes",level:2},{value:"Interface Dispatch (Static)",id:"interface-dispatch-static",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"classes",children:"Classes"})}),"\n",(0,i.jsx)(n.p,{children:"Mux provides object-oriented programming through classes and interfaces (traits)."}),"\n",(0,i.jsx)(n.h2,{id:"basic-class-definition",children:"Basic Class Definition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="basic_class.mux"',children:"class Circle {\n    float radius  // explicit type required for fields\n    \n    func area() returns float {\n        const float PI = 3.1415\n        return PI * self.radius * self.radius\n    }\n    \n    func circumference() returns float {\n        const float PI = 3.1415\n        return 2.0 * PI * self.radius\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Points:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Fields must have explicit types (no ",(0,i.jsx)(n.code,{children:"auto"})," inference)"]}),"\n",(0,i.jsxs)(n.li,{children:["Methods use ",(0,i.jsx)(n.code,{children:"self"})," to access instance fields"]}),"\n",(0,i.jsx)(n.li,{children:"Methods follow same rules as regular functions"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"class-instantiation",children:"Class Instantiation"}),"\n",(0,i.jsxs)(n.p,{children:["Classes use the ",(0,i.jsx)(n.code,{children:".new()"})," method pattern:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="class_instantiation.mux"',children:'// Basic instantiation\nauto circle = Circle.new()\n\n// With constructor arguments (if constructor is defined)\nauto circle2 = Circle.new(5.0)\n\n// Accessing fields and methods\ncircle.radius = 10.0\nauto area = circle.area()\nprint("Area: " + area.to_string())\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Design Note:"})," Mux uses explicit ",(0,i.jsx)(n.code,{children:".new()"})," rather than direct constructor calls to distinguish class instantiation from function calls and enum variant construction. The ",(0,i.jsx)(n.code,{children:".new()"})," method will ",(0,i.jsx)(n.em,{children:"always"}),' instantiate a new object with all default "zero" values for fields, and then you can set fields afterward. This is a simple and consistent pattern for object creation.']}),"\n",(0,i.jsxs)(n.p,{children:['The "Mux" style for a constructors is to use a ',(0,i.jsx)(n.code,{children:"common"})," (see ",(0,i.jsx)(n.a,{href:"/docs/language-guide/classes#static-methods-with-common",children:"below"}),") method that creates and initializes the object, rather than defining a special constructor syntax. This allows for more flexible object creation patterns while keeping the core class definition simple."]}),"\n",(0,i.jsx)(n.h2,{id:"interfaces-traits",children:"Interfaces (Traits)"}),"\n",(0,i.jsx)(n.p,{children:"Interfaces define required methods that classes must implement:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="interfaces.mux"',children:"interface Drawable {\n    func draw() returns void\n}\n\ninterface Measurable {\n    func area() returns float\n    func perimeter() returns float\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"implementing-interfaces",children:"Implementing Interfaces"}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"is"})," keyword to implement interfaces:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="implementing_interfaces.mux"',children:'class Circle is Drawable, Measurable {\n    float radius\n    \n    func draw() returns void {\n        auto message = "Circle radius=" + self.radius.to_string()\n        print(message)\n    }\n    \n    func area() returns float {\n        const float PI = 3.1415\n        return PI * self.radius * self.radius\n    }\n    \n    func perimeter() returns float {\n        const float PI = 3.1415\n        return 2.0 * PI * self.radius\n    }\n}\n\nclass Rectangle is Drawable, Measurable {\n    float width\n    float height\n    \n    func draw() returns void {\n        print("Rectangle " + self.width.to_string() + "x" + self.height.to_string())\n    }\n    \n    func area() returns float {\n        return self.width * self.height\n    }\n    \n    func perimeter() returns float {\n        return 2.0 * (self.width + self.height)\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," Use ",(0,i.jsx)(n.code,{children:"is"})," instead of ",(0,i.jsx)(n.code,{children:"implements"})," (like Java). Multiple interfaces separated by commas."]}),"\n",(0,i.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,i.jsx)(n.h3,{id:"instance-methods",children:"Instance Methods"}),"\n",(0,i.jsxs)(n.p,{children:["Access instance data via ",(0,i.jsx)(n.code,{children:"self"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="instance_methods.mux"',children:'class Counter {\n    int value\n    \n    func increment() returns void {\n        self.value = self.value + 1\n    }\n    \n    func reset() returns void {\n        self.value = 0\n    }\n    \n    func get() returns int {\n        return self.value\n    }\n}\n\nauto counter = Counter.new()\ncounter.increment()\ncounter.increment()\nprint(counter.get().to_string())  // "2"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"methods-with-unused-parameters",children:"Methods with Unused Parameters"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="class_unused_params.mux"',children:"class Config {\n    string name\n    \n    func update(string newName, string _) returns void {\n        self.name = newName  // second parameter ignored\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"static-methods-with-common",children:["Static Methods with ",(0,i.jsx)(n.code,{children:"common"})]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"common"})," keyword declares static (class-level) methods:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="static_methods.mux"',children:'class Stack<T> {\n    list<T> items\n    \n    // Instance method - operates on self\n    func push(T item) returns void {\n        self.items.push_back(item)\n    }\n    \n    // Static method - no self, called on class\n    common func who_am_i() returns string {\n        return "I\'m a Stack!"\n    }\n    \n    // Factory pattern - creates instances\n    common func from(list<T> init_list) returns Stack<T> {\n        auto new_stack = Stack<T>.new()\n        new_stack.items = init_list\n        return new_stack\n    }\n}\n\n// Calling static methods\nprint(Stack.who_am_i())                    // "I\'m a Stack!"\nauto s = Stack<int>.from([1, 2, 3])        // Factory method\n\n// Calling instance methods\nauto stack = Stack<int>.new()              // creates a new, empty `items` in the stack\nstack.push(42)\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"common-vs-const",children:[(0,i.jsx)(n.code,{children:"common"})," vs ",(0,i.jsx)(n.code,{children:"const"})]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Keyword"}),(0,i.jsx)(n.th,{children:"Purpose"}),(0,i.jsx)(n.th,{children:"Usage"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"common"})}),(0,i.jsx)(n.td,{children:"Static methods and factory functions"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ClassName.method()"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"const"})}),(0,i.jsx)(n.td,{children:"Immutable constants"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"const int MAX = 100"})})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Differences:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Instance methods"})," (no keyword) operate on ",(0,i.jsx)(n.code,{children:"self"})," and require an instance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Static methods"})," (",(0,i.jsx)(n.code,{children:"common"}),") have no ",(0,i.jsx)(n.code,{children:"self"})," and are called on the class"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Const fields"})," are immutable instance/class fields, not methods"]}),"\n",(0,i.jsxs)(n.li,{children:["Static methods cannot access instance fields (no ",(0,i.jsx)(n.code,{children:"self"})," context)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"constants-in-classes",children:"Constants in Classes"}),"\n",(0,i.jsx)(n.p,{children:"Classes can have constant (immutable) fields:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="class_constants.mux"',children:"class Config {\n    const int MAX_RETRIES\n    int current_retry\n    \n    func increment() returns void {\n        self.current_retry++  // OK - mutable field\n        // self.MAX_RETRIES++  // ERROR: Cannot modify const field\n    }\n}\n\nauto cfg = Config.new()\ncfg.current_retry = 1  // OK - mutable field\n// cfg.MAX_RETRIES = 5  // ERROR: Cannot assign to const field\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Const Enforcement:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Cannot reassign: ",(0,i.jsx)(n.code,{children:"self.MAX_RETRIES = value"})," \u2192 ERROR"]}),"\n",(0,i.jsxs)(n.li,{children:["Cannot increment/decrement: ",(0,i.jsx)(n.code,{children:"self.MAX_RETRIES++"})," \u2192 ERROR"]}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"const"})," for fields that shouldn't change after initialization"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"generic-classes",children:"Generic Classes"}),"\n",(0,i.jsx)(n.p,{children:"Classes can be generic over type parameters:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="class_generics.mux"',children:'class Pair<T, U> {\n    T first\n    U second\n    \n    func swap() returns Pair<U, T> {\n        return Pair<U, T>.new(self.second, self.first)\n    }\n    \n    common func from(T a, U b) returns Pair<T, U> {\n        auto pair = Pair<T, U>.new()\n        pair.first = a\n        pair.second = b\n        return pair\n    }\n}\n\n// Usage\nauto pair = Pair<int, string>.new()\npair.first = 42\npair.second = "answer"\n\nauto reversed = pair.swap()  // Pair<string, int>\n\n// Using factory method\nauto pair2 = Pair<string, int>.from("key", 100)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"/docs/language-guide/generics",children:"Generics"})," for more details."]}),"\n",(0,i.jsx)(n.h2,{id:"interface-dispatch-static",children:"Interface Dispatch (Static)"}),"\n",(0,i.jsxs)(n.p,{children:["Mux uses ",(0,i.jsx)(n.strong,{children:"static dispatch"})," for interfaces - no runtime vtable lookup:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mux",metastring:'title="static_dispatch.mux"',children:"func drawAll(list<Drawable> shapes) returns void {\n    for Shape shape in shapes {\n        shape.draw()  // Resolved at compile time\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why Static Dispatch?"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Zero cost"}),": No pointer indirection, direct function calls"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Inlining"}),": LLVM can inline interface methods"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Optimization"}),": Better branch prediction, no indirect jumps"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:'The tradeoff: interfaces cannot be added to types from other modules (no "extension traits").'}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fields must be explicitly typed"})," - No ",(0,i.jsx)(n.code,{children:"auto"})," for class fields"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use interfaces for polymorphism"})," - Define common behavior"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Use ",(0,i.jsx)(n.code,{children:"common"})," for factory methods"]})," - Create instances with pre-populated data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Keep classes focused"})," - Single responsibility principle"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Use ",(0,i.jsx)(n.code,{children:"const"})," for immutable fields"]})," - Prevent accidental modification"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Leverage generic classes"})," - Reusable data structures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Prefer static dispatch"})," - Better performance than dynamic dispatch"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/language-guide/generics",children:"Generics"})," - Generic classes and type parameters"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/language-guide/generics#built-in-interfaces",children:"Interfaces"})," - Built-in interfaces for common operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/language-guide/memory",children:"Memory"})," - Reference counting and object lifecycle"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/language-guide/functions",children:"Functions"})," - Method definitions"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>c,x:()=>a});var t=s(6540);const i={},r=t.createContext(i);function c(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);