---
source: mux-compiler/tests/source_integration.rs
expression: "format!(\"{:#?}\", expected)"
---
"// Comprehensive test for global variable scope support\n// Tests: simple access, modification, local shadowing, multiple functions, nested scopes\n\nprint(\"=== Testing Global Variable Access ===\")\n\n// Define global variables\nint global_counter = 0\nbool global_flag = true\nint global_value = 42\n\n// Test 1: Simple global access from function\nfunc read_global() returns int {\n    return global_value\n}\n\nint result1 = read_global()\nif result1 == 42 {\n    print(\"✓ Test 1: Functions can read global variables\")\n} else {\n    print(\"✗ FAIL: Expected 42, got \" + result1.to_string())\n}\n\nprint(\"\")\nprint(\"=== Testing Global Variable Modification ===\")\n\n// Test 2: Global modification from function\nfunc increment_counter() returns void {\n    global_counter = global_counter + 1\n}\n\nincrement_counter()\nif global_counter == 1 {\n    print(\"✓ Test 2: Functions can modify global variables (counter = 1)\")\n} else {\n    print(\"✗ FAIL: Expected counter = 1, got \" + global_counter.to_string())\n}\n\nincrement_counter()\nincrement_counter()\nif global_counter == 3 {\n    print(\"✓ Test 2b: Multiple calls accumulate changes (counter = 3)\")\n} else {\n    print(\"✗ FAIL: Expected counter = 3, got \" + global_counter.to_string())\n}\n\nprint(\"\")\nprint(\"=== Testing Local Variable Shadowing ===\")\n\n// Test 3: Local variable shadows global\nfunc test_shadowing() returns int {\n    int global_value = 100  // shadows the global\n    return global_value\n}\n\nint result3 = test_shadowing()\nif result3 == 100 {\n    print(\"✓ Test 3a: Local variable shadows global (got 100)\")\n} else {\n    print(\"✗ FAIL: Expected 100, got \" + result3.to_string())\n}\n\nif global_value == 42 {\n    print(\"✓ Test 3b: Global remains unchanged after shadowing (still 42)\")\n} else {\n    print(\"✗ FAIL: Global was modified, expected 42, got \" + global_value.to_string())\n}\n\nprint(\"\")\nprint(\"=== Testing Multiple Functions Sharing Globals ===\")\n\n// Test 4: Multiple functions share and modify the same global\nint shared_accumulator = 0\n\nfunc add_ten() returns void {\n    shared_accumulator = shared_accumulator + 10\n}\n\nfunc add_five() returns void {\n    shared_accumulator = shared_accumulator + 5\n}\n\nfunc get_accumulator() returns int {\n    return shared_accumulator\n}\n\nadd_ten()\nadd_five()\nadd_ten()\n\nint result4 = get_accumulator()\nif result4 == 25 {\n    print(\"✓ Test 4: Multiple functions share globals correctly (10+5+10 = 25)\")\n} else {\n    print(\"✗ FAIL: Expected 25, got \" + result4.to_string())\n}\n\nprint(\"\")\nprint(\"=== Testing Nested Scopes Within Functions ===\")\n\n// Test 5: Globals accessible in nested scopes (if/while blocks)\nint nested_test_var = 0\n\nfunc test_nested_scopes() returns void {\n    if true {\n        nested_test_var = nested_test_var + 1\n        if true {\n            nested_test_var = nested_test_var + 1\n        }\n    }\n    \n    int counter = 0\n    while counter < 3 {\n        nested_test_var = nested_test_var + 1\n        counter = counter + 1\n    }\n}\n\ntest_nested_scopes()\nif nested_test_var == 5 {\n    print(\"✓ Test 5: Globals accessible in nested scopes (2 from if, 3 from while = 5)\")\n} else {\n    print(\"✗ FAIL: Expected 5, got \" + nested_test_var.to_string())\n}\n\nprint(\"\")\nprint(\"=== Testing Global Boolean Operations ===\")\n\n// Test 6: Boolean globals\nfunc toggle_flag() returns void {\n    global_flag = !global_flag\n}\n\nif global_flag == true {\n    print(\"✓ Test 6a: Initial global_flag is true\")\n} else {\n    print(\"✗ FAIL: Expected global_flag to be true\")\n}\n\ntoggle_flag()\nif global_flag == false {\n    print(\"✓ Test 6b: toggle_flag() works (now false)\")\n} else {\n    print(\"✗ FAIL: Expected global_flag to be false\")\n}\n\ntoggle_flag()\nif global_flag == true {\n    print(\"✓ Test 6c: toggle_flag() works again (now true)\")\n} else {\n    print(\"✗ FAIL: Expected global_flag to be true\")\n}\n\nprint(\"\")\nprint(\"=== Testing Complex Global Updates ===\")\n\n// Test 7: Compound assignments and operations\nint math_global = 10\n\nfunc complex_math() returns void {\n    math_global = math_global * 2\n    math_global = math_global + 5\n    math_global = math_global - 3\n}\n\ncomplex_math()\nif math_global == 22 {\n    print(\"✓ Test 7: Complex math operations on globals (10*2+5-3 = 22)\")\n} else {\n    print(\"✗ FAIL: Expected 22, got \" + math_global.to_string())\n}\n\nprint(\"\")\nprint(\"=== All Global Scope Tests Completed ===\")\n"
