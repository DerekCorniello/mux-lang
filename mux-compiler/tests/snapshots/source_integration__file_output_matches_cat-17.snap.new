---
source: mux-compiler/tests/source_integration.rs
assertion_line: 28
expression: "format!(\"{:#?}\", expected)"
---
"// Enums and Classes - Extended Shapes Example\nenum Shape { Circ(float r), Rect(float w, float h) }  // Tagged union for shape data\n\ninterface DrawableShape { func draw() returns void }  // Interface for drawable behavior\n\nclass GenericShape is DrawableShape {\n    Shape shape  // Class contains enum for data\n    func draw() returns void {\n        println(\"in draw\")\n        match self.shape {\n            Circ(r) { \n                println(\"In Circ arm\")\n                println(\"Drawing circle with radius: \" + r.to_string())\n            }\n            Rect(w, h) { \n                println(\"In Rect arm\")\n                println(\"Drawing rectangle with width: \" + w.to_string() + \" height: \" + h.to_string()) \n            }\n            _ {\n                println(\"none\")\n            }\n        }\n    }\n\n    common func from(Shape init_shape) returns GenericShape {\n        GenericShape new_shape = GenericShape.new()\n        new_shape.shape = init_shape\n        return new_shape\n    }\n}\n\nclass Pair<T, U> {\n    T left\n    U right\n    common func from(T left, U right) returns Pair<T, U> {\n        auto new_pair = Pair<T, U>.new()\n        new_pair.left = left\n        new_pair.right = right\n        return new_pair\n    }\n\n    func get_left() returns T {\n        return self.left\n    }\n\n    func get_right() returns U {\n        return self.right\n    }\n}\n\n// Usage: Create shapes via enum, wrap in class for behavior\nauto circleShape = Shape.Circ(5.0)\nauto rectShape = Shape.Rect(10.0, 20.0)\n\nauto circle = GenericShape.from(circleShape)\nauto rect = GenericShape.from(rectShape)\nauto shapes = [circle, rect]\n\nfor GenericShape s in shapes {\n    s.draw()  // Polymorphic call via interface\n}\n\nauto homogenous_pair = Pair<int, int>.from(1, 9)\nauto heterogenous_pair = Pair<string, bool>.from(\"status successful\", true)\nauto heterogenous_pair_2 = Pair<string, bool>.from(\"status failed\", false)\n\nprintln(homogenous_pair.get_left().to_string())\nprintln(homogenous_pair.get_right().to_string())\n\nprintln(heterogenous_pair.get_left().to_string())\nprintln(heterogenous_pair.get_right().to_string())\n\nprintln(heterogenous_pair_2.get_left().to_string())\nprintln(heterogenous_pair_2.get_right().to_string())\n\nprintln(\"done\")\n"
