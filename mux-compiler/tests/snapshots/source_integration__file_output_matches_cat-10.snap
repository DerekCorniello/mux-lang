---
source: mux-compiler/tests/source_integration.rs
expression: "format!(\"{:#?}\", expected)"
---
"// Enums and Classes - Extended Shapes Example\nenum Shape { Circ(float r), Rect(float w, float h) }  // Tagged union for shape data\n\ninterface DrawableShape { func draw() returns void }  // Interface for drawable behavior\n\nclass GenericShape is DrawableShape {\n    Shape shape  // Class contains enum for data\n    func draw() returns void {\n        match shape {\n            Circ(r) { println(\"In Circ arm\") println(\"Drawing circle with radius: \" + r.to_string()) }\n            Rect(w, h) { println(\"In Rect arm\") println(\"Drawing rectangle with width: \" + w.to_string() + \" height: \" + h.to_string()) }\n        }\n    }\n}\n\nclass Pair<T is Printable, U is Printable> {\n    T left\n    U right\n    common func from(T left, U right) returns Pair<T, U> {\n        auto new_pair = Pair<T, U>.new()\n        new_pair.left = left\n        new_pair.right = right\n        return new_pair\n    }\n\n    func get_left() returns T {\n        return self.left\n    }\n\n    func get_right() returns U {\n        return self.right\n    }\n}\n\n// Usage: Create shapes via enum, wrap in class for behavior\nauto circleShape = Shape.Circ(5.0)\nauto rectShape = Shape.Rect(10.0, 20.0)\n\nauto circle = GenericShape.new(circleShape)\nauto rect = GenericShape.new(rectShape)\n\nauto shapes = [circle, rect]\n\nfor DrawableShape s in shapes {\n    s.draw()  // Polymorphic call via interface\n}\n\nauto homogenous_pair = Pair<int, int>.from(1, 9)\nauto heterogenous_pair = Pair<string, bool>.from(\"status successful\", true)\n"
