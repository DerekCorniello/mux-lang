// Enums and Classes - Extended Shapes Example
enum Shape { Circ(float r), Rect(float w, float h) }  // Tagged union for shape data

interface DrawableShape { func draw() returns void }  // Interface for drawable behavior

class GenericShape is DrawableShape {
    Shape shape  // Class contains enum for data
    func draw() returns void {
        match shape {
            Circ(r) { println("In Circ arm") println("Drawing circle with radius: " + r.to_string()) }
            Rect(w, h) { println("In Rect arm") println("Drawing rectangle with width: " + w.to_string() + " height: " + h.to_string()) }
        }
    }
}

class Pair<T is Printable, U is Printable> {
    T left
    U right
    common func from(T left, U right) returns Pair<T, U> {
        auto new_pair = Pair<T, U>.new()
        new_pair.left = left
        new_pair.right = right
        return new_pair
    }

    func get_left() returns T {
        return self.left
    }

    func get_right() returns U {
        return self.right
    }
}

// Usage: Create shapes via enum, wrap in class for behavior
auto circleShape = Shape.Circ(5.0)
auto rectShape = Shape.Rect(10.0, 20.0)

auto circle = GenericShape.new(circleShape)
auto rect = GenericShape.new(rectShape)

auto shapes = [circle, rect]

for DrawableShape s in shapes {
    s.draw()  // Polymorphic call via interface
}

auto homogenous_pair = Pair<int, int>.from(1, 9)
auto heterogenous_pair = Pair<string, bool>.from("status successful", true)
